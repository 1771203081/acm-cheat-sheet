\chapter{广度优先搜索}
当题目看不出任何规律，既不能用分治，贪心，也不能用动规时，这时候万能方法——搜索，
就派上用场了。搜索分为广搜和深搜，广搜里面又有普通广搜，双向广搜，A*搜索等。
深搜里面又有普通深搜，回溯法等。

广搜和深搜非常类似（除了在扩展节点这部分不一样），二者有相同的框架，如何表示状态？
如何扩展状态？如何判重？尤其是判重，解决了这个问题，基本上整个问题就解决了。


\section{算法框架} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
思考的步骤：
\begin{enumerate}
\item 如何表示状态？即一个状态需要存储哪些些必要的数据，就可以完整表示该状态？这一步不考虑是求长度还是求路径的问题，纯粹考虑状态本身的数据。
\item 是求最短路径长度，还是最短路径（或动作序列）？如果是求长度，则状态里面要存路径长度；如果是求路径或动作序列，则要用一棵树存储宽搜过程中的路径。
    \begin{enumerate}
    \item 如果是求长度，则状态里面要存路径长度
    \end{enumerate}
\item 是求最短路径长度，还是最短路径（或动作序列）？如果是求路径或动作序列
    \begin{enumerate}
    \item 要用一棵树存储宽搜过程中的路径
    \item 是否可以预估状态个数的上限？能够预估状态总数，则开一个大数组，用树的双亲表示法；如果不能预估状态总数，则要使用一棵通用的树（自己实现或用标准库）。这一步也是第4步的必要不充分条件。
   \end{enumerate}
\item 关于判重，状态是否存在完美哈希方案？即将状态一一映射到整数，互相之间不会冲突。
    \begin{enumerate}
    \item 如果不存在，则需要使用通用的哈希表（自己实现或用标准库，例如\fn{std::unordered_set}）来判重；
    \item 如果存在，则可以开一个大布尔数组，作为哈希表来判重，且此时可以精确计算出状态总数，而不仅仅是预估上限。
    \end{enumerate}
\end{enumerate}

\begin{Codex}[label=bfs_template.c]
#include <stdio.h>
#include <string.h>

/***** 输入数据，用全局变量存放 *****/
...
/*
例如
int m = MAXN, n = MAXN;  // 迷宫的行数，列数
// 迷宫，0表示空地，1表示障碍物
int map[MAXN][MAXN];  // 迷宫，0表示空地，1表示障碍物
 */

/***** 一些常量 *****/
...
/* 例如
// 四个方向
const char name[4] = { 'U', 'R', 'D', 'L' };
const int dx[4] = { -1, 0, 1, 0 }; // 行
const int dy[4] = { 0, 1, 0, -1 }; // 列
*/

#ifndef __cplusplus
typedef char bool;
#define false 0
#define true 1
#endif

/**
 * @strut 状态
 */
typedef struct state_t {
    ... data;  /** 状态的数据. */
    int action; /** 由父状态移动到本状态的动作 */
    int index;  /** 本父状态在path[]中的下标，求路径或动作序列时需要。
                    如果存在完美哈希，则不需要本字段（此时将
                   状态的哈希值作为下标，而哈希值可以直接计算出） */
    int father; /** 父状态在path[]中的下标，，求路径或动作序列时需要 */
    int count;  /** 所花费的步骤数（也即路径长度-1），求路径长度时需要 */
} state_t;

// 目标状态
const state_t END = {..., 0};

/********** 如果题目要求输出路径或动作序列，则需要下面的变量和函数 ***********/

#define STATE_MAX ...  /* 状态总数 */
/**
 * 记录动作序列，树的双亲表示法.
 * 如果不能预估状态个数的上限，则不能用数组，要用通用树
 * 一般此时会有完美哈希方案，开一个大数组存储每个状态的动作，下标就是状态的哈希值
 * 其实一般用不了这么大的数组，广搜很很快就会结束
 */
state_t path[STATE_MAX];
int path_index = 0;  /** 每出现一个新状态，就增1，将状态存到该位置 */

/**
 * @brief 打印动作序列.
 * 如果有完美哈希方案，状态的哈希值就是下标。
 * 起点状态没有父亲和动作为-1，因为它没有父状态，也就没有所谓的从父节点到它的动作。
 * @param[in] end 终点状态的下标
 * @return 父状态
 */
void print_action(const int end) {
    if (path[end].father == -1) return;

    print_action(path[end].father);
    putchar(name[path[end].action]);
}

/**
 * @brief 打印坐标序列.
 * 如果有完美哈希方案，状态的哈希值就是下标。
 * 起点状态没有父亲和动作为-1，因为它没有父状态，也就没有所谓的从父节点到它的动作。
 * @param[in] end 终点状态的哈希值
 * @return 父状态
 */
void print_path(const int end) {
    if (path[end].father == -1) {
        printf("(%d, %d)\n", end / n, end % n);
        return;
    }
    print_path(path[end].father);
    printf("(%d, %d)\n", end / n, end % n);
}

/********** 如果题目要求输出路径或动作序列，则需要上面的变量和函数 ***********/

/** 计算状态的哈希值，如果存在完美哈希方案，则定义本函数，否则不需要. */
int state_hash(const state_t *s);

/** 初始化查找表. */
void history_init();

/**
 * @brief 状态判重.
 * 一般用哈希表(set::unordered_set)，如果存在完美哈希，则用数组
 * @param[in] s 状态
 * @return 已经访问过，返回true，否则false
 */
bool history_contains(const state_t *s);

/**
 * @brief 标记该状态已经被访问
 * @param[in] s 状态
 * @return 无
 */
void history_insert(const state_t *s);

/**
 * @brief 扩展第一个状态.
 * @param[in] s 状态
 * @param[out] next 第一个状态
 * @return 如果还有下一个状态，返回true，否则返回false
 */
void state_extend_init(const state_t *s);

/**
 * @brief 扩展下一个状态.
 * @param[in] s 状态
 * @param[out] next 下一个状态
 * @return 如果还有下一个状态，返回true，否则返回false
 */
bool state_extend(const state_t *s, state_t *next);

/**
 * @brief 判断状态是否为目标.
 * @param[in] s 状态
 * @return 如果已经达到目标状态，返回true，否则false
 */
bool state_is_target(const state_t *s);

typedef state_t queue_elem_t; // 元素的类型
/* 等价于复制粘贴，这里为了节约篇幅，使用include，在OJ上提交时请用复制粘贴 */
#include "queue.c"  /* 见“栈和队列->队列”这节，如果是C++，则使用std::queue */
// 队列
queue_t q;

/*
 * @brief 广搜
 *
 * @param[in] x 入口的x坐标
 * @param[in] y 入口的y坐标
 * @return 无
 */
void bfs(state_t *start) {
    queue_init(&q, 16);
    history_init();

    start->action = -1;   /* 起点状态没有动作 */
    start->index = path_index++;
    start->father = -1;   /* 起点状态没有父状态 */
    start->count = 0;

    path[start->index] = *start;
    history_insert(start); // 千万别忘记了标记此处的访问记录
    queue_push(&q, *start);

    while (!queue_empty(&q)) {
        const state_t s = queue_front(&q);
        state_t next;
        queue_pop(&q);

        state_extend_init(&s);
        while (state_extend(&s, &next)) {
            if (state_is_target(&next)) {
                // printf("%d\n", next->count);
                queue_uninit(&q);
                return;
            }
            queue_push(&q, next);
            history_insert(&next);
        }
    }
    queue_uninit(&q);
}

int main(void) {
    //input
    ...

    state_t start = { ... };
    state_t end = { ... };

    bfs(&start);

    print_action(state_hash(&end) or end.index);
    printf("\n");
    print_path(state_hash(&end) or end.index);
    return 0;
}

/************ functions implement ************/

/* 哈希表容量，要大于状态总数，若存在完美哈希方案，则等于状态总数 */
#define HASH_CAPACITY ...

/** 哈希表，标记状态是否已访问过。
 * 如果存在完美哈希方案，则用数组作为哈希表，否则用std::unordered_set
 */
... visited
// 例如 bool visited[HASH_MAX];

int state_hash(const state_t *s) {
    ...
}

void history_init() {
    /* 如果是数组 */
    memset(visited, 0, sizeof(visited));
    /* 如果是 std::unordered_set */
    visited.clear();
}

bool history_contains(const state_t *s) {
    /* 如果是数组 */
    return visited[state_hash(s)] == true;
    /* 如果是 std::unordered_set */
    return visited.count(s) > 0;
}

void history_insert(const state_t *s) {
    /* 如果是数组 */
    visited[state_hash(s)] = true;
    /* 如果是 std::unordered_set */
    visited.insert(s);
}

/** 扩展节点时，记录当前到了什么哪一步.
 * 是state_extend_init()和state_extend()的共享变量
 */
int action_cur;
/* 动作的范围 */
#define ACTION_BEGIN ...
#define ACTION_END ...

void state_extend_init(const state_t *s) {
    action_cur = ACTION_BEGIN;
}

bool state_extend(const state_t *s, state_t *next) {
    // extract values from s
    value1 = ...
    value2 = ...
    while(action_cur < ACTION_END) {
        // apply action_cur to values
        value1 = ...
        value2 = ...
        next->count = s->count + 1;
        if (values are valid) {
            next->data = value1 value2 ...

            if (!history_contains(next)) { /* 判重 */
                next->action = action_cur;
                next->index = path_index++;
                next->father = s->index or state_hash(s);
                /* 记录路径 */
                path[next->index or state_hash(next)] = *next;
                action_cur++;  /* return前别忘了增1 */
                return true;
            }
        }
        action_cur++;
    }
    return false;
}

bool state_is_target(const state_t *s) {
    ...
    /* 例如 return state_hash(s) == state_hash(END)); */
    /* 例如 return s->data == END.data; */
}
\end{Codex}

\section{走迷宫} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{描述}
一个迷宫由一个01矩阵表示，每个单元格要么是空地（用0表示），要
么是障碍物（用1表示）。你的任务是找到一条从入口到出口的最短路径。任何时候都不能在障碍物格子中，也不
能走到迷宫之外。只能横着走或竖着走，不能斜着走。数据保证有唯一解。

\subsubsection{输入}
一个$5 \times 5$的二维数组

\subsubsection{输出}
左上角到右下角的最短路径

\subsubsection{样例输入}
\begin{Code}
0 1 0 0 0
0 1 0 1 0
0 0 0 0 0
0 1 1 1 0
0 0 0 1 0
\end{Code}

\subsubsection{样例输出}
(0, 0)
(1, 0)
(2, 0)
(2, 1)
(2, 2)
(2, 3)
(2, 4)
(3, 4)
(4, 4)

\subsubsection{分析}
既然求的是“最短”，很自然的思路是用BFS。举个例子，在如下图所示的迷宫中，假设
入口是左上角$(0,0)$，我们就从入口开始用BFS遍历迷宫，就可以算出从入口到
所有点的最短路径（如图~\ref{fig:maze}(a)所示），以及这些路径上每个节点的
前驱（如图~\ref{fig:maze}(b)所示）。

\begin{center}
\includegraphics{maze.png}\\
\figcaption{用BFS求迷宫中最短路径}\label{fig:maze}
\end{center}

\subsubsection{代码}
\begin{Codex}[label=maze.c]
#include <stdio.h>
#include <string.h>

#define MAXN 5

// 迷宫的行数，列数
int m = MAXN, n = MAXN;
// 迷宫，0表示空地，1表示障碍物
int map[MAXN][MAXN];

// 四个方向
const char name[4] = { 'U', 'R', 'D', 'L' };
const int dx[4] = { -1, 0, 1, 0 }; // 行
const int dy[4] = { 0, 1, 0, -1 }; // 列

#ifndef __cplusplus
typedef char bool;
#define false 0
#define true 1
#endif

typedef struct state_t {
    int data;
    int action;
    int father;
} state_t;

#define STATE_MAX MAXN*MAXN  /* 状态总数 */

state_t path[STATE_MAX];

void print_action(const int end) {
    if (path[end].father == -1) return;

    print_action(path[end].father);
    putchar(name[path[end].action]);
}

void print_path(const int end) {
    if (path[end].father == -1) {
        printf("(%d, %d)\n", end / n, end % n);
        return;
    }
    print_path(path[end].father);
    printf("(%d, %d)\n", end / n, end % n);
}

int state_hash(const state_t *s);

void history_init();

bool history_contains(const state_t *s);

void history_insert(const state_t *s);

void state_extend_init(const state_t *s);

bool state_extend(const state_t *s, state_t *next);

bool state_is_target(const state_t *s);

typedef state_t queue_elem_t; // 元素的类型

/* 等价于复制粘贴，这里为了节约篇幅，使用include，在OJ上提交时请用复制粘贴 */
#include "queue.c"  /* 见“栈和队列->队列”这节，如果是C++，则使用std::queue */

queue_t q;

void bfs(state_t *start) {
    queue_init(&q, 16);
    history_init();

    start->action = -1;
    start->father = -1;

    path[state_hash(start)] = *start;
    history_insert(start);
    queue_push(&q, *start);

    while (!queue_empty(&q)) {
        const state_t s = queue_front(&q);
        queue_pop(&q);
        state_t next;
        state_extend_init(&s);
        while (state_extend(&s, &next)) {
            if (state_is_target(&next)) {
                queue_uninit(&q);
                return;
            }
            queue_push(&q, next);
            history_insert(&next);
        }
    }
    queue_uninit(&q);
}

int main(void) {
    int i, j;

    for (i = 0; i < m; i++) {
        for (j = 0; j < n; j++) {
            scanf("%d", &map[i][j]);
        }
    }

    state_t start = {0, -1, -1}; /* 左上角为起点 */
    state_t end = {24, -1, -1};  /* 右下角为终点 */

    bfs(&start);
    print_path(state_hash(&end));
    return 0;
}

/********** functions implement **************/
/* 哈希表容量，要大于状态总数，若存在完美哈希方案，则等于状态总数 */
#define HASH_CAPACITY STATE_MAX
bool visited[HASH_CAPACITY];

int state_hash(const state_t *s) {
    return s->data;
}

void history_init() {
    memset(visited, 0, sizeof(visited));
}

bool history_contains(const state_t *s) {
    return visited[state_hash(s)] == true;
}

void history_insert(const state_t *s) {
    visited[state_hash(s)] = true;
}

int action_cur;
#define ACTION_BEGIN 0
#define ACTION_END 4

void state_extend_init(const state_t *s) {
    action_cur = ACTION_BEGIN;
}

bool state_extend(const state_t *s, state_t *next) {
    const int x = s->data / n;
    const int y = s->data % n;

    while(action_cur < ACTION_END) {
        const int nx = x + dx[action_cur];
        const int ny = y + dy[action_cur];

        if (nx >= 0 && nx < m && ny >= 0 && ny < n && !map[nx][ny]) {
            next->data = nx * n + ny;

            if (!history_contains(next)) { /* 判重 */
                /* 记录路径 */
                next->action = action_cur;
                next->father = state_hash(s);
                path[state_hash(next)] = *next;

                action_cur++;  /* return前别忘了增1 */
                return true;
            }
        }
        action_cur++;
    }
    return false;
}

bool state_is_target(const state_t *s) {
    return s->data == 24;
}
\end{Codex}

\subsubsection{相关的题目}
与本题相同的题目：
\begindot
\item 《算法竞赛入门经典》\footnote{刘汝佳,算法竞赛入门经典，清华大学出版社，2009}第108页6.4.2节
\item  POJ 3984 迷宫问题, \myurl{http://poj.org/problem?id=3984}
\myenddot

与本题相似的题目：
\begindot
\item  POJ 2049 Finding Nemo, \myurl{http://poj.org/problem?id=2049}
\myenddot


\section{八数码问题} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{subsec:eightDigits}

\subsubsection{描述}
编号为1$\sim$8的8个正方形滑块摆成3行3列，有一个格子空着，如图~\ref{fig:eightDigits}所示。

\begin{center}
\includegraphics{eight-digits.png}\\
\figcaption{用BFS求迷宫中最短路径}\label{fig:eightDigits}
\end{center}

每次可以把与空格相邻的滑块（有公共边才算相邻）移到空格中，而它原
来的位置就成了新的空格。目标局面固定如下（用$x$表示空格）：
\begin{Code}
1 2 3
4 5 6
7 8 x
\end{Code}

给定初始局面，计算出最短的移动路径。

\subsubsection{输入}
用一行表示一个局面，例如下面的这个局面：
\begin{Code}
 1  2  3
 x  4  6
 7  5  8
\end{Code}
可以表示为 1 2 3 x 4 6 7 5 8。 

\subsubsection{输出}
如果有解答，输出一个由四个字母'r','l','u','d'组成的移动路径。
如果没有，输出"unsolvable"。 

\subsubsection{样例输入}
\begin{Code}
2  3  4  1  5  x  7  6  8
\end{Code}

\subsubsection{样例输出}
\begin{Code}
ullddrurdllurdruldr
\end{Code}

\subsubsection{分析}
计算“最短”，很自然的想到BFS。

如何表示一个状态？本题是一个3*3的棋盘，状态有9!个，可以用一个32位整数表示，但15!已经超过32位整数的
范围，21！超过了64位整数的范围，因此4*4的棋盘可以用一个64位整数表示。超过4*4的棋盘，则无法用整数来
表示了，可以用一个数组来表示。

如何判重？用哈希表或者集合。哈希表的话，由于C++ STL 还没有 \fn{std::hashset}，
需要自己实现哈希表，然后由于本题的特殊性，存在一种完美哈希(perfect hashing)方案。集合可以直接
使用\fn{std::set}。总结起来，有以下三个方法：
\begindot
\item 把排列变成整数，这是一种完美哈希，即不存在冲突
\item 用普通的哈希表，这种方法通用一些，速度也略慢。手工实现哈希表，把哈希值相同的组成一个单链表，
\item 用 \fn{std::set} 实现判重，代码最短，速度也最慢（本题用这个方法会TLE）。建议把该方法作为“跳板”，
先写一个STL版的程序，确保主算法正确，然后把\fn{std::set}替换成自己写的哈希表。
\myenddot

此题更优的解法还有双向BFS（见\S \ref{sec:biBFS}），A*算法（见\S \ref{sec:astar}）。

\subsubsection{代码}
\begin{Codex}[label=eight_digits_bfs.c]
/* POJ 1077 Eight, http://poj.org/problem?id=1077 */
#include <stdio.h>
#include <string.h>

#define DIGITS 9 // 棋盘中数字的个数，也是变进制数需要的位数
#define     MATRIX_EDGE 3       // 棋盘边长

/***** 一些常量 *****/
const int SPACE_NUMBER = 0; // 空格对应着数字 0
// 上下左右四个方向
const int dx[] = {-1, 1, 0, 0};
const int dy[] = {0, 0, -1, 1};
const char name[] = { 'u', 'd', 'l', 'r' };

#ifndef __cplusplus
typedef char bool;
#define false 0
#define true 1
#endif

/**
 * @strut 状态
 */
typedef struct state_t {
    int data[DIGITS];  /** 状态的数据. */
    int action; /* 由父状态移动到本状态的动作 */
    int father; /* 父状态的哈希值 */
} state_t;

// 目标状态
const state_t END = {{1, 2, 3, 4, 5, 6, 7, 8, 0}, -1, -1};

// 3x3的棋盘，状态最多有 9!种
#define STATE_MAX 362880  /* 状态总数 */

state_t path[STATE_MAX+1];

/**
 * @brief 打印动作序列.
 * @param[in] end 终点状态的哈希值
 * @return 父状态
 */
void print_action(const int end) {
    if (path[end].father == -1) return;

    print_action(path[end].father);
    putchar(name[path[end].action]);
}

int state_hash(const state_t *s);

void history_init();

bool history_contains(const state_t *s);

void history_insert(const state_t *s);

void state_extend_init(const state_t *s);

bool state_extend(const state_t *s, state_t *next);

bool state_is_target(const state_t *s);

typedef state_t queue_elem_t; // 元素的类型
/* 等价于复制粘贴，这里为了节约篇幅，使用include，在OJ上提交时请用复制粘贴 */
#include "queue.c"  /* 见“栈和队列->队列”这节，如果是C++，则使用std::queue */
// 队列
queue_t q;

/*
 * @brief 广搜
 *
 * @param[in] x 入口的x坐标
 * @param[in] y 入口的y坐标
 * @return 无
 */
void bfs(state_t *start) {
    queue_init(&q, 16);
    history_init();

    start->action = -1;
    start->father = -1;

    path[state_hash(start)] = *start;
    history_insert(start); // 千万别忘记了标记此处的访问记录
    queue_push(&q, *start);

    while (!queue_empty(&q)) {
        const state_t s = queue_front(&q);
        state_t next;
        queue_pop(&q);

        state_extend_init(&s);
        while (state_extend(&s, &next)) {
            if (state_is_target(&next)) {
                queue_uninit(&q);
                return;  /*TODO: 在此处打断点，return后会出现栈错误*/
            }
            queue_push(&q, next);
            history_insert(&next);
        }
    }
    queue_uninit(&q);
}

/**
 * @brief 输入.
 * @return 无
 */
void input(state_t *start) {
    int ch, i;
    for (i = 0; i < DIGITS; ++i) {
        do {
            ch = getchar();
        } while ((ch != EOF) && ((ch < '1') || (ch > '8')) && (ch != 'x'));
        if (ch == EOF) return;
        if (ch == 'x') start->data[i] = 0; // x 映射成数字 0
        else           start->data[i] = ch - '0';
    }
//    front = 0; rear = 1;
//    father[0] = 0; // 初始状态无父状态
//    distance[0] = 0;
//    move[0] = -1;
}

/** for wikioi 1225 */
int input1() {
    int start;
    scanf("%d", &start);
    return start;
}

int main(void) {
    state_t start;
    input(&start);

    bfs(&start);

    print_action(state_hash(&END));
    printf("\n");
    return 0;
}

/********** functions implement **************/

/********** 方案1 把排列变成整数 **************/
// 9 位变进制数（空格）能表示0到(9!-1)内的所有自然数,恰好有9!个，
// 与状态一一对应，因此可以把状态一一映射到一个9位变进制数

// 9 位变进制数，每个位数的单位，0!~8!
const int fac[] = {40320, 5040, 720, 120, 24, 6, 2, 1, 1};
/* 哈希表容量，要大于状态总数，若存在完美哈希方案，则等于状态总数 */
#define HASH_CAPACITY STATE_MAX

bool visited[HASH_CAPACITY];

int state_hash(const state_t *s) {
    int i, j;
    int key = 0; // 将 q[index] 映射到整数 key
    for (i = 0; i < DIGITS; i++) {
        int cnt = 0;
        for (j = i + 1; j < DIGITS; j++) if (s->data[i] > s->data[j]) cnt++;
        key += fac[i] * cnt;
    }
    return key;
}

void history_init() {
    memset(visited, 0, sizeof(visited));
}

bool history_contains(const state_t *s) {
    return visited[state_hash(s)] == true;
}

void history_insert(const state_t *s) {
    visited[state_hash(s)] = true;
}

int action_cur;
#define ACTION_BEGIN 0
#define ACTION_END 4

void state_extend_init(const state_t *s) {
    action_cur = ACTION_BEGIN;
}

bool state_extend(const state_t *s, state_t *next) {
    int x, y, z;
    for (z = 0; z < DIGITS; z++) {
        if (s->data[z] == SPACE_NUMBER) {
            break;  // 找 0 的位置
        }
    }
    x = z / MATRIX_EDGE; // 行
    y = z % MATRIX_EDGE; // 列

    while (action_cur < ACTION_END) {
        const int newx = x + dx[action_cur];
        const int newy = y + dy[action_cur];
        const int newz = newx * MATRIX_EDGE + newy;

        if (newx >= 0 && newx < MATRIX_EDGE && newy >= 0 && newy < MATRIX_EDGE) { // 没有越界
            *next = *s;
            next->data[newz] = SPACE_NUMBER;
            next->data[z] = s->data[newz];
            if (!history_contains(next)) { /* 判重 */
                next->action = action_cur;
                next->father = state_hash(s);
                /* 记录路径 */
                path[state_hash(next)] = *next;
                action_cur++; /* return前别忘了增1 */
                return true;
            }
        }
        action_cur++;
    }
    return false;
}

bool state_is_target(const state_t *s) {
    return state_hash(s) == state_hash(&END);
}
\end{Codex}

\subsubsection{相关的题目}
与本题相同的题目：
\begindot
\item 《算法竞赛入门经典》\footnote{刘汝佳,算法竞赛入门经典，清华大学出版社，2009} 第131页7.5.3节
\item  POJ 1077 Eight, \myurl{http://poj.org/problem?id=1077}
\item  wikioi 1225 八数码难题, \myurl{http://www.wikioi.com/problem/1225/}
\myenddot

与本题相似的题目：
\begindot
\item  POJ 2893 M × N Puzzle, \myurl{http://poj.org/problem?id=2893}
\myenddot


\section{四子连棋} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{描述}
在一个4*4的棋盘上摆放了14颗棋子，其中有7颗白色棋子，7颗黑色棋子，有两个空白地带，任何一颗黑白
棋子都可以向上下左右四个方向移动到相邻的空格，这叫行棋一步，黑白双方交替走棋，任意一方可以先走，
如果某个时刻使得任意一种颜色的棋子形成四个一线（包括斜线），这样的状态为目标棋局。

\subsubsection{输入}
一个4*4的初始棋局，黑棋子用B表示，白棋子用W表示，空格地带用O表示。

\subsubsection{输出}
移动到目标棋局的最少步数。

\subsubsection{样例输入}
\begin{Code}
BWBO
WBWB
BWBW
WBWO
\end{Code}

\subsubsection{样例输出}
\begin{Code}
5
\end{Code}

\subsubsection{分析}
求最少步数，很自然的想到广搜。

如何表示一个状态？用一个二维数组\fn{int board[4][4]}表示，还需要记录该状态是由白子还是黑子移动而导致的，走到该状态已经花费的步数。

如何扩展节点？每一步，从队列弹出一个状态，两个空格都可以向四个方向扩展，把得到的状态入队列。

如何判重？棋盘用二维矩阵存储，用0表示空格，1表示黑色，2表示白色，所以最后可以看成一个16位的三进制数。
用这个数作为棋盘的编码，就可以用来判重了。注意，本题要黑白交替走，所以我们要区分状态是由白子还是黑子移动而导致的。

可以用C++的\fn{std::map}来判重，
\begin{Code}
/* history[0]记录白子的历史，history[1]记录黑子的历史. */
std::map<int, bool> history[2];
\end{Code}

也可以开一个大数组当做哈希表，
\begin{Code}
#define HASH_MOD 43036875 /* hash表大小 */
/* history[0]记录白子的历史，history[1]记录黑子的历史. */
bool history[2][HASH_MOD];
\end{Code}

\subsubsection{代码}
\begin{Codex}[label=four_adjacent.c]
/** wikioi 1004 四子连棋  , http://www.wikioi.com/problem/1004 */
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <stdbool.h>

#define LEN 4   /* 边长 */
#define RADIX 3 /* 三进制 */
#define HASH_MOD 43036875 /* hash表大小 */

/* 右，左，上，下（左下角为坐标原点）*/
const int dx[] = { 1, -1, 0, 0 };
const int dy[] = { 0, 0, 1, -1 };

/** 状态. */
typedef struct status_t {
    int hash; /* board 对应的hash值  */
    int step; /* 走了步到达本状态 */
    int last; /* 本状态是由白子还是黑子移动而导致的 */
    int board[LEN][LEN]; /* 棋局，1表示黑子，2表示白子，0表示空白 */
} status_t;

status_t first; /* 初始输入的棋局. */

/* history[0]记录白子的历史，history[1]记录黑子的历史. */
bool history[2][HASH_MOD];


typedef status_t queue_elem_t; /* 元素的类型 */

/* 等价于复制粘贴，这里为了节约篇幅，使用include，在OJ上提交时请用复制粘贴 */
#include "queue.c"

/** 队列 */
queue_t q;


/**
 * @brief 计算棋盘所表示的三进制数转化为十进制数.
 * 棋盘用二维矩阵存储，用0表示空格，1表示黑色，2表示白色，所以最后可以看成
 * 一个16位的三进制数。最大为
 * 2222
 * 2221
 * 1111
 * 1100
 * 值为 43036875。
 * @return 棋盘所表示的三进制数转化为十进制数
 */
//TODO:共C16 7×C9 2个状态，用类似康托的方法储存
int hash(const int board[LEN][LEN]) {
    int i, j;
    int ret = 0;
    for (i = 0; i < LEN; i++) {
        for (j = 0; j < LEN; j++) {
            ret = ret * RADIX + board[i][j];
        }
    }
    return ret;
}

/**
 * 检查是否有四个棋子连成一线.
 * @return 有，返回1，没有，返回0
 */
bool check(status_t a) {
    int i, j;
    for (i = 0; i < LEN; i++) {  /* 逐行检查 */
        int flag = 1;  /* 某一行全是同一颜色 */
        for (j = 1; j < LEN; j++)
            if (a.board[i][j - 1] != a.board[i][j])
                flag = 0;
        if (flag)
            return 1;
    }
    for (j = 0; j < LEN; j++) { //逐列检查
        int flag = 1;  /* 某一行全是同一颜色 */
        for (i = 1; i < LEN; i++)
            if (a.board[i][j] != a.board[i - 1][j])
                flag = 0;
        if (flag)
            return 1;
    }
    /* 斜线 */
    if (a.board[0][0] == a.board[1][1] && a.board[1][1] == a.board[2][2]
            && a.board[2][2] == a.board[3][3])
        return 1;
    if (a.board[0][3] == a.board[1][2] && a.board[1][2] == a.board[2][1]
            && a.board[2][1] == a.board[3][0])
        return 1;
    return 0;
}

/** (x,y)是空白棋子的位置，将(x,y)朝(dx[k],dy[k])方向移动. */
void move(status_t now, int x, int y, int k) {
    status_t next = now;
    int nextx = x + dx[k];
    int nexty = y + dy[k];

    /* 越界 */
    if (nextx < 0 || nextx >= LEN)
        return;
    if (nexty < 0 || nexty >= LEN)
        return;

    if (next.board[nextx][nexty] == next.last)
        return; /* 必须黑白交替走 */

    next.last = 3 - next.last;
    /* swap */
    {
        int temp = next.board[x][y];
        next.board[x][y] = next.board[nextx][nexty];
        next.board[nextx][nexty] = temp;
    }
    next.hash = hash(next.board);
    next.step++;
    if (check(next)) {
        printf("%d\n", next.step);
        exit(0);
    }
    if (!history[next.last - 1][next.hash]) {
        history[next.last - 1][next.hash] = true;
        queue_push(&q, next);
    }
}

void bfs() {
    int i, j, k;
    first.hash = hash(first.board);
    first.last = 1;
    queue_push(&q, first);
    first.last = 2;
    queue_push(&q, first);

    while (!queue_empty(&q)) {
        status_t now = queue_front(&q);
        queue_pop(&q);
        int x1 = -1, x2 = -1, y1 = -1, y2 = -1; //两个空白的格子
        for (i = 0; i < LEN; i++) {
            for (j = 0; j < LEN; j++) {
                if (now.board[i][j] == 0) {
                    if (x1 == -1 && y1 == -1) {
                        x1 = i;
                        y1 = j;
                    } else {
                        x2 = i;
                        y2 = j;
                    }
                }
            }
        }
        for (k = 0; k < 4; k++) {
            move(now, x1, y1, k);
            move(now, x2, y2, k);
        }
    }
}

int main() {
    int i, j;
    char s[LEN + 1];
    queue_init(&q, 32);
    for (i = 0; i < LEN; i++) {
        scanf("%s", s);
        for (j = 0; j < LEN; j++) {
            if (s[j] == 'B')
                first.board[i][j] = 1;
            else if (s[j] == 'W')
                first.board[i][j] = 2;
        }
    }
    bfs();
    queue_uninit(&q);
    return 0;
}
\end{Codex}

\subsubsection{相关的题目}
与本题相同的题目：
\begindot
\item  wikioi 1004 四子连棋, \myurl{http://www.wikioi.com/problem/1004/}
\myenddot

与本题相似的题目：
\begindot
\item  None
\myenddot


\section{双向BFS} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:biBFS}


\subsection{八数码问题}
题目见 \S \ref{subsec:eightDigits}。

\subsubsection{代码}

\begin{Codex}[label=eight_digits_bibfs.c]

\end{Codex}


\section{A*算法} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:astar}

\textbf{A*算法 = 宽搜 + 优先队列}

\subsection{八数码问题}
题目见 \S \ref{subsec:eightDigits}。

\subsubsection{代码}
\begin{Codex}[label=eight_digits_astar.c]
/** POJ 1077 Eight, http://poj.org/problem?id=1077
 简单解释几个要点,便于理解代码.
 1. 怎么判断是否有解？只要计算出的逆序个数总和为奇数，该数据必然无解
 2. 如何判断某一状态是否到过？本题存在一种完美哈希方案，即用康托展开。
    详见 http://128kj.iteye.com/blog/1699795
    2.1.将一个状态视为数字 0-8 的一个排列，将此排列转化为序数，作为此状
 态的 HASH 值。0表示空格.转化算法此处不再赘述。

    2.2.排列转化为序数，用序数作为hash值
    例，1 2 3 这三个数字的全排列，按字典序，依次为
 123 -- 0
 132 -- 1
 213 -- 2
 231 -- 3
 312 -- 4
 321 -- 5
 其中，左侧为排列，右侧为其序数。

 3.使用数据结构 —— 堆，加速挑选最优值。

 4.函数 g 的计算，此状态在搜索树中已经走过的路径的节点数.

 5.估价函数 h ，采用曼哈顿距离, 见代码 calcH 函数。曼哈顿距离的定义是，
 假设有两个点(x1,y1),(x2,y2)，则曼哈顿距离L1=|x1-x2| + |y1-y2|
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// 3x3的棋盘，状态最多有 9!种
// 8位变进制数（空格）能表示0到(9!-1)内的所有自然数,恰好有9!个，
// 与状态一一对应，因此可以把状态一一映射到一个8位变进制数
#define     MAX         362880

#define DIGITS 9 // 棋盘中数字的个数，也是变进制数需要的位数
#define     MATRIX_EDGE 3       // 棋盘边长

#define     MOD         10      // 按十取模

typedef struct {
    int state; // 状态
    int parent;     // 父状态
    int flag;   // -1 表示已经展开过了closed，0表示死节点，1 表示还未展开, open
    int g, h, f; // 三个评估函数
    char choice;  // 左右上下四个方向移动，见全局常量 DI DJ DC
} state_t;

state_t states[MAX];  // 全局的一条状态变化路径

int  startIndex, goalIndex; // 开始状态，目标状态对应的hash值

// 目标状态
const int GOAL = 123456780;
// 每个数字在棋盘中的位置，例如0，在(2,2)=8这个位置上
int GOAL_POS[DIGITS];
const int SPACE_NUMBER = 0; // 空格对应着数字 0

// 上下左右四个方向
const int DI[] = {-1, 1, 0, 0};
const int DJ[] = {0, 0, -1, 1};
const char DC[] = { 'u', 'd', 'l', 'r' };

// 9 位变进制数，每个位数的单位，0!~8!
const int fac[] = {40320, 5040, 720, 120, 24, 6, 2, 1, 1};

/* 计算GOAL_POS */
void calc_goal_pos() {
    int cur = GOAL;
    int i;
    for (i = DIGITS-1; i >= 0 ; i--) {
        int digit = cur % MOD;
        GOAL_POS[digit] = i;
        cur /= MOD;
    }
}

/**
 * @brief 计算状态的hash值，这里用康托展开，是完美哈希.
 *
 * @param[in] s 当前状态
 * @return 序数，作为hash值
 */
int hash(int s) {
    int i, j;
    int d[DIGITS];
    int key = 0;

    for(i = DIGITS - 1; i >=0; i--) {
        d[i] = s % MOD;
        s /= MOD;
    }

    for (i = 0; i < DIGITS; i++) {
        int c = 0; // 逆序数
        for (j = i + 1; j < DIGITS; j++) {
            if(d[j] < d[i]) {
                c++;
            }
        }
        key += c * fac[i];
    }

    return key;
}


/**
 * 估价函数h。
 * @param s 状态
 * @return 预估代价
 */
int calcH(int s) {
    int i;
    int h = 0;

    for (i = DIGITS - 1; i >= 0; --i) {
        const int p = s % 10;
        s /= 10;
        // 曼哈顿距离
        h += abs(i / MATRIX_EDGE - GOAL_POS[p] / MATRIX_EDGE) +
            abs(i % MATRIX_EDGE - GOAL_POS[p] % MATRIX_EDGE);
    }
    return h;
}

/**
 * @brief 输入.
 * @return  成功返回数字，失败返回0
 * @remark 《算法竞赛入门经典》第131页7.5.3节，是用0表示空格，
 * POJ 1077是用'x'表示空格，前者简化了一点，POJ 1077还需要把'x'映射成0
 */
int input() {
    int ch, i;
    int start = 0;
    for (i = 0; i < DIGITS; ++i) {
        do {
            ch = getchar();
        } while ((ch != EOF) && ((ch < '1') || (ch > '8')) && (ch != 'x'));
        if (ch == EOF) return 0;
        if (ch == 'x') start = start * MOD + SPACE_NUMBER; // x 映射成数字 0
        else             start = start * MOD + ch - '0';
    }
    return start;
}

/** for wikioi 1225 */
int input1() {
    int start;
    scanf("%d", &start);
    return start;
}

/**
 * 计算一个排列的逆序数，0 除外.
 */
int inversion_count(int permutation) {
    int i, j;
    int d[DIGITS];
    int c = 0; // 逆序数

    for(i = DIGITS - 1; i >=0; i--) {
        d[i] = permutation % MOD;
        permutation /= MOD;
    }

    for (i = 1; i < DIGITS; i++)  if (d[i] != SPACE_NUMBER) {
        for (j = 0; j < i; j++) {
            if(d[j] != SPACE_NUMBER) {
                if (d[j] > d[i]) {
                    c++;
                }
            }
        }
    }
    return c;
}

/**
 * 判断是否无解.
 *
 * 求出除0之外所有数字的逆序数之和，也就是每个数字后面比它小的数字的个数的和，
 * 称为这个状态的逆序。
 *
 * 若起始状态和目标状态的逆序数奇偶性相同，则可相互到达，否则不可相互到达。
 *
 * @param s 目标状态
 * @return 1表示有解，0表示无解
 */
int solvable(const int s) {
    return (inversion_count(s) + inversion_count(GOAL)) % 2 == 0;
}

// 存放 next()的输出结果
char choice[4]; // 四个防线
int nextIndex[4]; // 接下来的四个状态

/*
 * @brief 向四个方向扩展
 * @param[in] s 状态
 * @return 无
 */
void next(int s) {
    int i, j, k;
    int p[MATRIX_EDGE][MATRIX_EDGE]; // 一个状态对应的矩阵
    int i0, j0;  // 空格位置

    for (i = MATRIX_EDGE - 1; i >= 0; i--) {
        for (j = MATRIX_EDGE - 1; j >= 0; j--) {
            p[i][j] = s % MOD;
            s /= MOD;
            if (p[i][j] == SPACE_NUMBER) {
                i0 = i;
                j0 = j;
            }
        }
    }
    // 向四个方向探索
    for (k = 0; k < 4; ++k) {
        const int sx = i0 + DI[k]; // 空格的新位置(sx, sy)
        const int sy = j0 + DJ[k];
        if ((sx >= 0) && (sx < 3) && (sy >= 0) && (sy < 3)) {
            int key;
            p[i0][j0] = p[sx][sy];
            p[sx][sy] = SPACE_NUMBER;
            // 移动空格后，计算新的状态
            s = 0;
            for (i = 0; i < MATRIX_EDGE; i++)
                for (j = 0; j < MATRIX_EDGE; j++)
                    s = s * MOD + p[i][j];
            p[sx][sy] = p[i0][j0]; // 将矩阵还原，(i0, j0)可以不管

            key = nextIndex[k] = hash(s);
            choice[k] = DC[k];
            if (states[key].state == 0) { // 该状态还没有出现过
                states[key].state = s;
                states[key].h = calcH(s);
            }
        } else {// 越界了
            nextIndex[k] = -1;
        }
    }
}

/** 状态的比较函数 */
int cmp_state(const int *x, const int *y) {
    return states[*x].f - states[*y].f;
}

/* 等价于复制粘贴，这里为了节约篇幅，使用include，在OJ上提交时请用复制粘贴 */
#include "heap.c"  /* 见“树->堆”这节 */

heap_t heap;
int heapIndex[MAX + 4]; // 状态 x 在heap中的下标

/**
 * @brief A*搜索
 * @param[in] start 初始状态
 * @return 如果无解，返回0，如果有解返回1
 */
int astar(const int start) {
    int i, j, k, ng, nf;
    if (!solvable(start)) return 0;

    startIndex = hash(start);
    goalIndex  = hash(GOAL);
    if (start == GOAL) return 1;

    memset(states, 0, sizeof(states));
    states[startIndex].state = start;
    states[startIndex].flag    = 1;
    states[startIndex].g       = 0;
    states[startIndex].h       = states[startIndex].f = calcH(start);

    heap_push(&heap, startIndex);
    while(!heap_empty(&heap)) {
        i = heap_top(&heap); heap_pop(&heap);
        if (i == goalIndex) return 1; // 找到目标，返回

        states[i].flag = -1;
        ng = states[i].g + 1;
        next(states[i].state);
        for (k = 0; k < 4; ++k) {
            j = nextIndex[k];
            if (j < 0) continue;
            nf = ng + states[j].h;
            if ((states[j].flag == 0) || ((states[j].flag == 1) &&
                (nf < states[j].f))) {
                states[j].parent = i;
                states[j].choice = choice[k];
                states[j].g    = ng;
                states[j].f    = nf;
                if (states[j].flag > 0) {
                    heap_sift_up(&heap, heapIndex[j]);
                    heap_sift_down(&heap, heapIndex[j]);
                } else {
                    heap_push(&heap, j);
                    states[j].flag = 1;
                }
            }
        }
    }
    return 0;
}

/* 等价于复制粘贴，这里为了节约篇幅，使用include，在OJ上提交时请用复制粘贴 */
#include "stack.c"  /* 见“栈和队列->栈”这节 */

/**
 * @brief 打印移动序列.
 * @return 无
 */
void output() {
    int i;
    stack_t stack;
    stack_init(&stack, MAX);

    for (i = goalIndex; i != startIndex; i = states[i].parent) {
        stack_push(&stack, states[i].choice);
    }
    while(!stack_empty(&stack)) {
        printf("%c", stack_top(&stack));
        stack_pop(&stack);
    }

    printf("\n");
    stack_uninit(&stack);
}

/**
 * @brief 打印棋盘的每次变化.
 * @return 无
 */
void output1() {
    int i;
    int d[DIGITS];
    stack_t stack;
    stack_init(&stack, MAX);

    for (i = goalIndex; i != startIndex; i = states[i].parent) {
        stack_push(&stack, states[i].state);
    }
    stack_push(&stack, states[startIndex].state);

    while(!stack_empty(&stack)) {
        stack_elem_t tmp = stack_top(&stack);
        stack_pop(&stack);
        for(i = DIGITS - 1; i >=0; i--) {
            d[i] = tmp % MOD;
            tmp /= MOD;
        }
        for(i = 0; i < DIGITS; i++) {
            if((i + 1) % MATRIX_EDGE == 0) {
                printf("%d\n", d[i]);
            } else {
                printf("%d ", d[i]);
            }
        }
        printf("\n");
    }
    stack_uninit(&stack);
}

int main() {
    calc_goal_pos();
    const int start = input();
    heap_init(&heap, MAX + 4, cmp_state);

    if (astar(start))  output();
    else printf("no solution\n");

    heap_uninit(&heap);
    return 0;
}
\end{Codex}
