\chapter{图}
在ACM竞赛中，图一般使用邻接矩阵表示，代码框架如下；

\begin{Codex}[label=graph.c]
#define MAXN 100  // 顶点最大个数

int n; // 顶点个数
int G[MAXN][MAXN]; // 邻接矩阵
int visited_edges[MAXN][MAXN]; // 边的访问历史记录
int visited_vertices[MAXN]; // 顶点的访问历史记录
\end{Codex}

\section{深度优先搜索} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
图的深度优先搜索的代码框架如下：

\begin{Codex}[label=graph.c]
/**
 * @brief 图的深度优先搜索代码框架，搜索边.
 * @param[in] u 出发顶点
 * @param[in] n 顶点个数
 * @param[in] G 图的临街举着
 * @param[in] visited 边的访问历史记录
 * @return 无
 * @remark 在使用的时候，为了降低递归的内存占用量，可以把
 * n, G, visited 抽出来作为全局变量
 */
void dfs(const int u, 
                const int n, const int G[][MAXN], int visited[][MAXN]) {
    int v;
    for(v = 0;  v < n; v++) if(G[u][v] && !visited[u][v]) {
        visited[u][v] = visited[v][u] = 1; // 无向图用这句
        // visited_edges[u][v] = 1; // 有向图用这句
        dfs(v, n, G, visited);
        // 这里写逻辑代码
        // printf("%d %d\n", u, v);
    }
}

/**
 * @brief 图的深度优先搜索代码框架，搜索顶点.
 * @param[in] u 出发顶点
 * @param[in] n 顶点个数
 * @param[in] G 图的临街举着
 * @param[in] visited 顶点的访问历史记录
 * @return 无
 * @remark 在使用的时候，为了降低递归的内存占用量，可以把
 * n, G, visited 抽出来作为全局变量
 */
void dfs(const int u, 
                const int n, const int G[][MAXN], int visited[MAXN]) {  
    int v;
    visited[u] = 1;
    for(v = 0;  v < n; v++) if(G[u][v] && !visited[v]) {
        dfs(v, n, G, visited);
        // 这里写逻辑代码
        // printf("%d %d\n", u, v);
    }
}
\end{Codex}

\subsection{黑白图像}

\subsubsection{描述}
输入一个n*n的黑白图像（1表示黑丝，0表示白色），任务是统计其中八连块的个数。
如果两个黑格子有公共边或者公共定点，就说它们属于同一个八连块。如图~\ref{fig:blackwhiteImage}所示的
黑白图像中有3个八连块。

\begin{center}
\includegraphics[width=90pt]{blackwhite-image.jpg}\\
\figcaption{拥有3个八连块的黑白图}\label{fig:blackwhiteImage}
\end{center}

\subsubsection{代码}
\begin{Codex}[label=blackwhite_image.c]
#include <stdio.h>
#include <string.h>

#define MAXN 16

int n;
// 黑白图，1 表示黑色，0表示白色，加一圈0，用于判断出界
int G[MAXN + 1][MAXN + 1];
// 记录格子(x,y)是否已经被访问过
int visitied[MAXN][MAXN];

void dfs(const int x, const int y) {
    // 曾经访问过这个格子，或者当前格子是白色
    if(G[x][y] == 0 || visitied[x][y] == 1)  return;
    
    visitied[x][y] = 1; // 标记(x,y)已访问过
    // 递归访问周围的8个格子
    dfs(x - 1, y - 1); // 左上角
    dfs(x - 1, y); // 正上方
    dfs(x - 1, y + 1); // 右上角
    dfs(x, y - 1); // 左边
    dfs(x, y + 1); // 右边
    dfs(x + 1, y - 1); // 左下角
    dfs(x + 1, y); // 正下方
    dfs(x + 1, y + 1); // 右下角
}

/*
Sample Input
6
100100
001010
000000
110000
111000
010100
Sample Output
3
*/
int main() {
    int i, j;
    char s[MAXN]; // 矩阵的一行
    int count = 0; // 八连块的个数

    scanf("%d", &n);
    memset(G, 0, sizeof(G));
    memset(visitied, 0, sizeof(visitied));

    for(i = 0; i < n; ++i) {
        scanf("%s", s);
        for(j = 0; j < n; ++j) {
            G[i + 1][j + 1] = s[j] - '0'; // 把图像往中间挪一点，空出一圈白格子
        }
    }


    for(i = 1; i <= n; ++i) {
        for(j = 1; j <= n; ++j) {
            if(visitied[i][j] == 0 && G[i][j] == 1) {
                count++;
                dfs(i, j);
            }
        }
    }
    printf("%d\n", count);
    return 0;
}
\end{Codex}

\subsubsection{相关的题目}
与本题相同的题目：
\begindot
\item 《算法竞赛入门经典》\footnote{刘汝佳,算法竞赛入门经典，清华大学出版社，2009} 第107页6.4.1节
\item  TODO
\myenddot

与本题相似的题目：
\begindot
\item  TODO
\myenddot

\subsection{欧拉回路}

\subsubsection{描述}
本题是 UVA 10054 - The Necklace。

My little sister had a beautiful necklace made of colorful beads. Two successive beads in the 
necklace shared a common color at their meeting point. The figure below shows a segment of 
the necklace:

\centerline{\fbox{\includegraphics[width=240pt]{uva10054.png}}}

But, alas! One day, the necklace was torn and the beads were all scattered over the floor. 
My sister did her best to recollect all the beads from the floor, but she is not sure 
whether she was able to collect all of them. Now, she has come to me for help. She wants
 to know whether it is possible to make a necklace using all the beads she has in the same
 way her original necklace was made and if so in which order the bids must be put.

Please help me write a program to solve the problem.

\subsubsection{Input}
The input contains T test cases. The first line of the input contains the integer T.

The first line of each test case contains an integer $N(5 \leq N \leq 1000)$ giving the number of beads 
my sister was able to collect. Each of the next N lines contains two integers describing 
the colors of a bead. Colors are represented by integers ranging from 1 to 50.

\subsubsection{Output}
For each test case in the input first output the test case number as shown in the sample output. Then 
if you apprehend that some beads may be lost just print the sentence ``some beads may be lost" on a 
line by itself. Otherwise, print N lines with a single bead description on each line. Each bead 
description consists of two integers giving the colors of its two ends. For $1 \leq i \leq N_1$, the second integer 
on line i must be the same as the first integer on line i + 1. Additionally, the second integer 
on line N must be equal to the first integer on line 1. Since there are many solutions, any one
 of them is acceptable.

Print a blank line between two successive test cases.

\subsubsection{Sample Input}
\begin{Code}
2
5
1 2
2 3
3 4
4 5
5 6
5
2 1
2 2
3 4
3 1
2 4
\end{Code}

\subsubsection{Sample Output}
\begin{Code}
Case \#1
some beads may be lost

Case \#2
2 1
1 3
3 4
4 2
2 2
\end{Code}

\subsubsection{分析}
这题就是欧拉回路+打印路径。

如果能从图的某一顶点出发，每条边恰好经过一次，这样的路线称为\textbf{欧拉道路}(Eulerian Path)。
如果每条边恰好经过一次，且能回到起点，这样的路线称为\textbf{欧拉回路}(Eulerian Circuit)。

对于无向图G，当且仅当G是连通的，且最多有两个奇点，则存在欧拉道路。
如果有两个奇点，则必须从其中一个奇点出发，到另一个奇点终止。

如果没有奇点，则一定存在一条欧拉回路。

对于有向图G，当且仅当G是连通的，且每个点的入度等于出度，则存在欧拉回路。

如果有两个顶点的入度与出度不相等，且一个顶点的入度比出度小1，另一个顶点的入度比出度大1，此时，
存在一条欧拉道路，以前一个顶点为起点，以后一个顶点为终点

\subsubsection{代码}
\begin{Codex}[label=eulerian_circuit.c]
#include <stdio.h>
#include<string.h>

#define MAXN 51  // 顶点最大个数

int G[MAXN][MAXN];
int visited_vertices[MAXN]; 
int visited_edges[MAXN][MAXN];
int count[MAXN]; // 顶点的度

void dfs(const int u) {  
    int v;
    visited_vertices[u] = 1;
    for(v = 0;  v < MAXN; v++) if(G[u][v] && !visited_vertices[v]) {
        dfs(v);
    }
}

/*
 * @brief 欧拉回路，允许自环和重复边
 * @param[in] u 起点
 * @return 无
 */
void euler(const int u){
    int v;
    for(v = 0; v < MAXN; ++v) if(G[u][v]){
        --G[u][v]; --G[v][u]; // 这个技巧，即有visited的功能，又允许重复边
        euler(v);
        // 逆向打印，或者存到栈里再打印
        printf("%d %d\n", u, v);
    }
}

int main() {
    int T, N, a, b;
    int i;
    int cases=1;
    scanf("%d",&T);
    while(T--) {
        int flag = 1; // 结点的度是否为偶数
        int flag2 = 1; // 图是否是连通的
        
        memset(G, 0, sizeof(G));
        memset(count, 0, sizeof(count));

        scanf("%d",&N);
        for(i = 0; i < N; ++i){
            scanf("%d %d", &a, &b); 
            ++G[a][b];
            ++G[b][a];
            ++count[a];
            ++count[b];
        }

        printf("Case #%d\n", cases++);

        // 欧拉回路形成的条件之一，判断结点的度是否为偶数
        for(i=0; i<MAXN; ++i) {
            if(count[i] & 1){
                flag = 0;
                break;
            }
        }
        // 检查图是否连通
        if(flag) {
            memset(visited_vertices, 0, sizeof(visited_vertices));
            memset(visited_edges, 0, sizeof(visited_edges));

            for(i=0; i< MAXN; ++i) 
                if(count[i]) { 
                    dfs(i);
                    break; 
                }
            for(i=0; i< MAXN; ++i){
                if(count[i] && !visited_vertices[i]) {
                    flag2 = 0; 
                    break;
                }
            }
        }
        if (flag && flag2) {
            for(i = 0; i < MAXN; ++i) if(count[i]){
                euler(i);
                break;
            }
        } else {
            printf("some beads may be lost\n");
        }

        if(T > 0) printf("\n");
    }
    return 0;
}
\end{Codex}

\subsubsection{相关的题目}
与本题相同的题目：
\begindot
\item 《算法竞赛入门经典》\footnote{刘汝佳,算法竞赛入门经典，清华大学出版社，2009} 第111页6.4.4节
\item  TODO
\myenddot

与本题相似的题目：
\begindot
\item  UVa 10129 Play on Words, \myurl{http://t.cn/zTInBDX}
\myenddot

\section{广度优先搜索} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

我们通常说的BFS，默认指的是单向BFS，此外还有双向BFS。

\subsection{走迷宫}

\subsubsection{描述}
一个迷宫由$n$行$m$列的单元格组成，每个单元格要么是空地（用0表示），要
么是障碍物（用1表示）。你的任务是找到一条从入口到出口的最短移动序列，
其中UDLR分别表示上下左右四个方向。任何时候都不能再障碍物格子中，也不
能走到迷宫之外。入口和出口保证是空地。$n,m \leq 100$。

\subsubsection{分析}
既然求的是“最短”，很自然的思路是用BFS。举个例子，在如下图所示的迷宫中，假设
入口是左上角$(0,0)$，我们就从入口开始用BFS遍历迷宫，就可以算出从入口到
所有点的最短路径（如图~\ref{fig:maze}(a)所示），以及这些路径上每个节点的
前驱（如图~\ref{fig:maze}(b)所示）。

\begin{center}
\includegraphics{maze.png}\\
\figcaption{用BFS求迷宫中最短路径}\label{fig:maze}
\end{center}

\subsubsection{代码}
\begin{Codex}[label=maze.c]
#include <stdio.h>
#include <string.h>

#define MAXN 100

// 迷宫的行数，列数
int n, m;
// 迷宫，0表示空地，1表示障碍物
int G[MAXN][MAXN];
// 标记格子是否已访问过
int visited[MAXN][MAXN];
// 每个格子的前驱
int father[MAXN][MAXN];
// 前趋到该格子的前进方向
int last_direction[MAXN][MAXN];

// 四个方向
const char name[4] = {'U','R','D','L'};
const int dx[4] = {-1, 0, 1, 0}; // 行
const int dy[4] = {0, 1, 0, -1}; // 列

// 队列
int q[MAXN * MAXN];

/*
 * @brief 广搜
 *
 * @param[in] x 入口的x坐标
 * @param[in] y 入口的y坐标
 * @return 无
 */
void bfs(int x, int y) {
    int front = 0, rear = 0;
    int u = x * m + y;
    int d; // 方向
    
    father[x][y] = u; // 打印路径时的终止条件
    visited[x][y] = 1;// 千万别忘记了标记此处的访问记录
    q[rear++] = u;
    while (front < rear) {
        u = q[front++];
        x = u / m;	y = u % m;
        for(d = 0; d < 4; d++) { // 代表四个方向
            const int nx = x + dx[d];
            const int ny = y + dy[d];
            
            if (nx >= 0 && nx < n && ny >= 0 && ny < m &&  // //(nx, ny)没有出界
                !G[nx][ny] && !visited[nx][ny]) { // 不是障碍且没被访问过
                const int v = nx * m + ny;
                q[rear++] = v;
                father[nx][ny] = u; // 记录(nx, ny)的前趋
                visited[nx][ny] = 1; // 访问记录
                last_direction[nx][ny] = d; // 记录从(x, y)到(nx, ny)的方向
            }
        }
    }
}

/*
 * @brief 递归实现路径输出
 *
 * 如果格子(x, y)有父亲(fx, fy)，需要先打印出从入口到(fx, fy)的最短路径，然后再
 * 打印从 (fx, fy)到 (x,y) 的移动方向。
 *
 * @param[in] x 目标点的x坐标
 * @param[in] y 目标点的y坐标
 * @return 无
 */
void print_path_r(const int x, const int y) {
    const int fx = father[x][y] / m;
    const int fy = father[x][y] % m;
    if (fx != x || fy != y) {
        print_path_r(fx, fy);
        putchar(name[last_direction[x][y]]);
    }
}

int direction[MAXN * MAXN];
/*
 * @brief 显式栈实现路径输出
 *
 * @param[in] x 目标点的x坐标
 * @param[in] y 目标点的y坐标
 * @return 无
 */
void print_path(int x, int y) {
    int c = 0;
    while(1) {
        const int fx = father[x][y] / m;
        const int fy = father[x][y] % m;
        if (fx == x && fy == y) break;
        direction[c++] = last_direction[x][y];
        x = fx;
        y = fy;
    }
    while (c--) {
        putchar(name[direction[c]]);
    }
}

/*
Sample Input
6 5
00100
01000
01011
01000
00010
00000
Sample Output
(0,0)-->(0,4), DDDDRRUUURUR
*/
int main(void) {
    int i, j;
    char s[MAXN];

    scanf("%d%d", &n, &m);

    for(i = 0; i < n; i++) {
        scanf("%s", s);
        for(j = 0; j < m; j++) {
            G[i][j] = s[j] - '0';
        }
    }

    printf("从入口到出口迷宫路径：\n");
    bfs(0, 0);	// (0, 0)是入口
    print_path(0, 4); // (0, 4) 是出口
    printf("\n");
    return 0;
}
\end{Codex}

\subsubsection{相关的题目}
与本题相同的题目：
\begindot
\item 《算法竞赛入门经典》\footnote{刘汝佳,算法竞赛入门经典，清华大学出版社，2009}第108页6.4.2节
\item  POJ 3984 迷宫问题, \myurl{http://poj.org/problem?id=3984}
\myenddot

与本题相似的题目：
\begindot
\item  POJ 2049 Finding Nemo, \myurl{http://poj.org/problem?id=2049}
\myenddot

\subsection{八数码问题}
\label{subsec:eightDigits}

\subsubsection{描述}
编号为1$\sim$8的8个正方形滑块摆成3行3列，有一个格子空着，如图~\ref{fig:eightDigits}所示。

\begin{center}
\includegraphics{eight-digits.png}\\
\figcaption{用BFS求迷宫中最短路径}\label{fig:eightDigits}
\end{center}

每次可以把与空格相邻的滑块（有公共边才算相邻）移到空格中，而它原
来的位置就成了新的空格。目标局面固定如下（用$x$表示空格）：
\begin{Code}
1 2 3
4 5 6
7 8 x
\end{Code}

给定初始局面，计算出最短的移动路径。

\subsubsection{输入}
用一行表示一个局面，例如下面的这个局面：
\begin{Code}
 1  2  3
 x  4  6
 7  5  8
\end{Code}
可以表示为 1 2 3 x 4 6 7 5 8。 

\subsubsection{输出}
如果有解答，输出一个由四个字母'r','l','u','d'组成的移动路径。
如果没有，输出"unsolvable"。 

\subsubsection{样例输入}
\begin{Code}
2  3  4  1  5  x  7  6  8
\end{Code}

\subsubsection{样例输出}
\begin{Code}
ullddrurdllurdruldr
\end{Code}

\subsubsection{分析}
计算“最短”，很自然的想到BFS。

如何表示一个状态？本题是一个3*3的棋盘，状态有9!个，可以用一个32位整数表示，但15!已经超过32位整数的
范围，21！超过了64位整数的范围，因此4*4的棋盘可以用一个64位整数表示。超过4*4的棋盘，则无法用整数来
表示了，可以用一个数组来表示。

怎么判断一个状态已经访问过？用哈希表或者集合。哈希表的话，由于C++ STL 还没有 \fn{std::hashset}，
需要自己实现哈希表，然后由于本题的特殊性，存在一种完美哈希(perfect hashing)方案。集合可以直接
使用\fn{std::set}。总结起来，有以下三个方法：
\begindot
\item 把排列变成整数，这是一种完美哈希，即不存在冲突
\item 用普通的哈希表，这种方法通用一些，速度也略慢。手工实现哈希表，把哈希值相同的组成一个单链表，
\item 用 \fn{std::set} 实现判重，代码最短，速度也最慢（本题用这个方法会TLE）。建议把该方法作为“跳板”，
先写一个STL版的程序，确保主算法正确，然后把\fn{std::set}替换成自己写的哈希表。
\myenddot

此题更优的解法还有双向BFS（见\S \ref{sec:biBFS}），A*算法（见\S \ref{sec:astar}）。

\subsubsection{代码}
\begin{Codex}[label=eight_digits_bfs.c]
#include <stdio.h>
#include <string.h>
#include <assert.h>

#define DIGITS 9 // 棋盘中数字的个数，也是变进制数需要的位数
#define     MATRIX_EDGE 3       // 棋盘边长

// 3x3的棋盘，状态最多有 9!种
#define     MAX         362880

typedef int state_t[DIGITS]; // 单个状态

state_t q[MAX]; // 队列，也是哈希表
int front, rear;
int distance[MAX - 1]; // 由初始状态到本状态的最短步数
int father[MAX - 1]; // 父状态，初始状态无父状态
char move[MAX - 1]; // 父状态到本状态的移动方向

// 目标状态
const int goal[] = {1, 2, 3, 4, 5, 6, 7, 8, 0};
const int space_number = 0; // 空格对应着数字 0

// 上下左右四个方向
const int dx[] = {-1, 1, 0, 0};
const int dy[] = {0, 0, -1, 1};
const char dc[] = { 'u', 'd', 'l', 'r' };

/**
 * @brief 初始化哈希表.
 * @return 无
 */
void init_lookup_table(); // 版本 1

/**
 * @brief 插入到 visited表中.
 * @param[in] index 状态在队列中的位置
 * @return 成功返回1，失败返回0
 */
int try_to_insert(const int index);

void init_lookup_table_hash(); // 版本2
int try_to_insert_hash(const int index);

void init_lookup_table_stl(); // 版本3
int try_to_insert_stl(const int index);

/**
 * @brief 单向BFS.
 * @return 返回目标状态在队列q中的下标 ，失败则返回0
 */
int bfs() {
    // 三个版本随意切换
    init_lookup_table();
    // init_lookup_table_hash();
    // init_lookup_table_stl(); // 这个版本会 Time Limit Exceeded

    while (front < rear) {
        int x, y, z, d;
        const state_t*s = &(q[front]);
        if (memcmp(goal, *s,sizeof(state_t)) == 0) {
            return front;  // 找到目标状态，成功返回
        }
        for (z = 0; z < DIGITS; z++)  if ((*s)[z] == space_number) {
            break;  // 找 0 的位置
        }
        
        x=z / MATRIX_EDGE, y=z % MATRIX_EDGE; // 获取行列编号
        for (d=0; d < 4; d++) {  // 向四个方向扩展
            const int newx = x + dx[d];
            const int newy = y + dy[d];
            const int newz = newx * MATRIX_EDGE + newy;

            if (newx >= 0 && newx < MATRIX_EDGE && newy >= 0 &&
                newy < MATRIX_EDGE) { // 没有越界
                state_t *t = &(q[rear]);
                memcpy(t, s, sizeof((*s)));
                assert((*s)[z] == space_number);
                (*t)[newz] = space_number;
                (*t)[z] = (*s)[newz];

                // 三个版本随意切换
                if (try_to_insert(rear)) { // 利用查找表判重
                // if (try_to_insert_hash(rear)) {
                // if (try_to_insert_stl(rear)) {
                    father[rear] = front;
                    move[rear] = dc[d];
                    distance[rear] = distance[front] + 1;
                    rear++;
                } 
            }
        }

        front++;
    }

    return 0;//失败 
}


/**
 * @brief 输入.
 * @return 无
 */
void input() {
    int ch, i;
    for (i = 0; i < DIGITS; ++i) {
        do {
            ch = getchar();
        } while ((ch != EOF) && ((ch < '1') || (ch > '8')) && (ch != 'x'));
        if (ch == EOF) return;
        if (ch == 'x') q[0][i] = 0; // x 映射成数字 0
        else           q[0][i] = ch - '0';
    }
    front = 0; rear = 1;
    father[0] = 0; // 初始状态无父状态
    distance[0] = 0;
    move[0] = -1;
    return;
}

int top = -1;
char stack[MAX];
/**
 * @brief 打印从初始状态到目标状态的移动序列.
 * @param[in] index 目标状态在队列q中的下标
 * @return 无
 */
void output(const int index) {
    int i;
    for (i = index; i > 0; i = father[i]) {
        stack[++top] = move[i];
    }
    for (i = top; i >= 0; --i) {
        printf("%c", stack[i]);
    }
    printf("\n");
}

int main() {
    int ans;

    input();
    
    ans = bfs();
    if ( ans > 0) {
        output(ans);
    } else {
        printf("no solution\n");
    }
    return 0;
}

/***********************方案1 把排列变成整数**************************/
// 9 位变进制数（空格）能表示0到(9!-1)内的所有自然数,恰好有9!个，
// 与状态一一对应，因此可以把状态一一映射到一个9位变进制数

// 9 位变进制数，每个位数的单位，0!~8!
const int fac[] = {40320, 5040, 720, 120, 24, 6, 2, 1, 1};

// 采用本方案，由于是完美哈希，没有冲突，
// 可以用 MAX 代替 MAX_HASH_SIZE，减少内存占用量
int visited[MAX]; // 历史记录表

/** 初始化哈希表. */
void init_lookup_table() {
    memset(visited, 0, sizeof(visited));
}

/**
 * @brief 计算状态的hash值，这里用康托展开，是完美哈希.
 *
 * @param[in] s 状态
 * @return 序数，作为hash值
 */
int hash(const state_t *s) {
    int i, j;
    int key = 0; // 将 q[index] 映射到整数 key
    for (i = 0; i < 9; i++) {
        int cnt = 0;
        for (j = i + 1; j < 9; j++) if ((*s)[i] > (*s)[j]) cnt++;
        key += fac[i] * cnt;
    }
    return key;
}

/**
 * @brief 插入到 visited表中.
 * @param[in] index 状态在队列中的位置
 * @return 成功返回1，失败返回0
 */
int try_to_insert(const int index) {
    const int key = hash(&q[index]); // 将 q[index] 映射到整数 code
    
    if (visited[key]) return 0;
    else visited[key] = 1;

    return 1;
}

/**************************方案2 哈希表**********************************/
#define MAX_HASH_SIZE  1000000  // 状态的哈希表容量，比 9! 大即可

int head[MAX_HASH_SIZE];
int next[MAX];

void init_lookup_table_hash() {
    memset(head, 0, sizeof(head));
    memset(next, 0, sizeof(next));
}
int hash2(const state_t *s) {
    int i;
    int v = 0;
    for(i = 0; i < 9; i++) v = v * 10 + (*s)[i];
    return v % MAX_HASH_SIZE;
}

int try_to_insert_hash(const int index) {
    const int h = hash2(&(q[index]));
    int u = head[h]; // 从表头开始查找单链表
    while(u) {
        // 找到了，插入失败
        if(memcmp(q[u], q[index], sizeof(state_t)) == 0) return 0;
        u = next[u]; // 顺着链表继续找
    }
    next[index] = head[h]; // 插入到链表中
    head[h] = index; // head[h]和 next[index] 组成了一个节点
    return 1;
}

/****************************方案3 STL************************************/
#include <set>
struct cmp {
    bool operator() (int a, int b) const {
        return memcmp(&q[a], &q[b], sizeof(state_t)) < 0;
    }
};
std::set<int, cmp> visited_set;

void init_lookup_table_stl() { visited_set.clear(); }

int try_to_insert_stl(const int index) {
    if (visited_set.count(index)) return 0;
    visited_set.insert(index);
    return 1;
}
\end{Codex}

\subsubsection{相关的题目}
与本题相同的题目：
\begindot
\item 《算法竞赛入门经典》\footnote{刘汝佳,算法竞赛入门经典，清华大学出版社，2009} 第131页7.5.3节
\item  POJ 1077 Eight, \myurl{http://poj.org/problem?id=1077}
\myenddot

与本题相似的题目：
\begindot
\item  POJ 2893 M × N Puzzle, \myurl{http://poj.org/problem?id=2893}
\myenddot

\section{双向BFS} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:biBFS}
\subsection{八数码问题}
题目见 \S \ref{subsec:eightDigits}。

\textbf{代码}

\begin{Codex}[label=eight_digits_bibfs.c]
\end{Codex}

\section{最小生成树} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
“最小”指的是边的权值之和最小。

构造最小生成树(Minimum Spanning Tree, MST)有多种算法。其中多数算法利用了最小生成树的一个性质（简称为MST性质）：假设$N=(V, E)$是一个连通网，$U$是顶点集$V$的一个非空子集。若$(u, v)$是一条具有最小权值的边，其中$u \in U, v \in V-U$，则必存在一颗包含边$(u, v)$的最小生成树。

Prim算法和Kruskal算法是两个利用MST性质构造最小生成树的算法。它们都属于贪心法。

\subsection{Prim算法}
假设$N=(V, E)$是一个连通网，$TE$是$N$上最小生成树中边的集合。算法从$U={u_0}(u_0 \in V), TE=\{\}$开始，重复执行下述操作：在所有$u \in U, v \in V-U$的边$(u, v) \in E$中找一条代价最小的边$(u_0, v_0)$并入集合$TE$，同时$v_0$并入U，直至$U=V$为止。此时$TE$中必有$n-1$条边，则$T=(V, TE)$为$N$的最小生成树。
为实现这个算法需附设一个数组\fn{closedge}，以记录从$U$到$V-U$具有最小代价的边。对每个顶点$v_i \in V-U$，在辅助数组中存在一个相应分量\fn{closedge[i-1]}，它包括两个域，其中\fn{lowcost}存储该边上的权。显然，$closedge[i].lowcost=\min\left\{cost(u, v_i), u \in U\right\}$。\fn{adjvex}域存储该边依附的在U中的顶点。

图 \ref{fig:prim}所示为按Prim算法构造网的一棵最小生成树的过程，在构造过程中辅助数组中各分量值的变化如表\ref{tab:prim}所示。

\begin{center}
\includegraphics[width=240pt]{prim1.png}\\
\includegraphics[width=240pt]{prim2.png}\\
\includegraphics[width=240pt]{prim3.png}\\
\figcaption{Prim算法构造最小生成树的过程}\label{fig:prim}
\end{center}

\begin{center}
\tabcaption{构造最小生成树过程中辅助数组的变化}
\label{tab:prim}
\begin{tabular}{|c|cccccccc|}
\hline
\textbf{\diagbox{closedge}{i}} & \textbf{1} & \textbf{2} & \textbf{3} & \textbf{4}& \textbf{5}& \textbf{U}& \textbf{U-V}& \textbf{k}\\
\hline
adjvex & $v_0$ & $v_0$ & $v_0$ & & & $v_0$ & $\{v_1,v_2,v_3,v_4,v_5\}$ & \multirow{2}{*}{2} \\
lowcost & 6 & 1 & 5 & & & & & \\
\hline
adjvex & $v_2$ & & $v_1$ & $v_2$ & $v_2$ & $\{v_0,v_2\}$ & $\{v_1,v_3,v_4,v_5\}$ & \multirow{2}{*}{5} \\
lowcost & 5 & 0 & 5 & 6 & 4 & & & \\
\hline
adjvex & $v_2$ & & $v_6$ & $v_2$ & & $\{v_0,v_2,v_5\}$ & $\{v_1,v_3,v_4\}$ & \multirow{2}{*}{3} \\
lowcost & 5 & 0 & 2 & 6 & 0 & & & \\
\hline
adjvex & $v_2$ & & & $v_2$ & & $\{v_0,v_2,v_5,v_3\}$ & $\{v_1,v_4\}$ & \multirow{2}{*}{1} \\
lowcost & 5 & 0 & 0 & 6 & 0 & & & \\
\hline
adjvex & & & & $v_1$ & & $\{v_0,v_2,v_5,v_3,v_1\}$ & $\{v_4\}$ & \multirow{2}{*}{4} \\
lowcost & 0 & 0 & 0 & 3 & 0 & & & \\
\hline
adjvex & & & & & & $\{v_0,v_2,v_5,v_3,v_1,v_4\}$ & $\{\}$ & \multirow{2}{*}{} \\
lowcost & 0 & 0 & 0 & 0 & 0 & & & \\
\hline
\end{tabular}
\end{center}


\subsubsection{代码}

\begin{Codex}[label=mgraph_prim1.c]
#include <stdio.h>
#include <stdlib.h>  /* for malloc() */
#include <limits.h>  /* for INT_MAX */

/** 顶点数的最大值*/
#define MAX_VERTICES_NUM 100
/** 边的权值，对无权图，用0或1表示是否相邻；对有权图，则为权值. */
typedef int graph_weight_t;
/** 顶点信息，例如顶点名字. */
typedef char graph_vertex_t;

/**
 *@struct
 *@brief 邻接矩阵.
 */
typedef struct mgraph_t {
    int vertices_num; /* 顶点数*/
    int edges_num; /* 边数*/
    /* 顶点表，存放顶点的信息，如名字等*/
    graph_vertex_t vertices[MAX_VERTICES_NUM];
    /* 邻接矩阵，存放边的信息，如权重等*/
    graph_weight_t matrix[MAX_VERTICES_NUM][MAX_VERTICES_NUM];
    int directed; /* 图(网)的种类，1表示有向，0表示无向*/
} mgraph_t;

mgraph_t g;

typedef struct closedge_t {
    int adjvex; /* 弧头，属于U */
    graph_weight_t lowcost; /* 边 adjvex->本下标 的权值，INT_MIN表示已经加入U */
} closedge_t;

/*
 * @brief 在V-E集合中寻找最小的边
 * @param[in] closedge MST中的边，起点为adjvex，终点为本下标
 * @param[in] n closedge数组的长度
 * @return 找到了则返回弧尾的下标，V-U为空集则返回-1，表示终止
 */
static int min_element(const closedge_t closedge[], int n) {
    int i;
    int min_value = INT_MAX;
    int min_loc = -1;
    for (i = 0; i < n; i++)
        if (closedge[i].lowcost > INT_MIN) {
            if (min_value > closedge[i].lowcost) {
                min_value = closedge[i].lowcost;
                min_loc = i;
            }
        }
    return min_loc;
}

/**
 * @brief Prim算法，求图的最小生成树.
 * @param[in] g 图对象的指针
 * @return MST的边的权值之和
 */
graph_weight_t mgraph_prim(const mgraph_t *g) {
    graph_weight_t sum = 0; /* 权值之和 */
    int i, j;
    int u = 0; /* 从0号顶点出发 */
    const int n = g->vertices_num;
    /* closedge[n]，记录从顶点集U到V-U的边*/
    closedge_t* const closedge = (closedge_t*) malloc(n * sizeof(closedge_t));

    /* 辅助数组初始化*/
    for (i = 0; i < n; i++) if (i != u) {
        closedge[i].adjvex = u;
        closedge[i].lowcost = g->matrix[u][i];
    }
    closedge[u].lowcost = INT_MIN; /* 初始, U={u} */

    for (i = 0; i < n; i++) if (i != u) { /* 其余的n-1个顶点*/
        /* 求出TE的下一个顶点k */
        const int k = min_element(closedge, n);
        /* 输出此边 closedge[k].adjvex --> k */
        printf("%c - %c\n", g->vertices[closedge[k].adjvex], g->vertices[k]);
        sum += g->matrix[closedge[k].adjvex][k];
        // sum += closedge[k].lowcost;  // 等价
        closedge[k].lowcost = INT_MIN;  /* 顶点k并入U，表示此边加入TE */
        /* 更新k的邻接点的值，不相邻为无穷大*/
        for (j = 0; j < n; j++) {
            const graph_weight_t w = g->matrix[k][j];
            if (w < closedge[j].lowcost) {
                closedge[j].adjvex = k;
                closedge[j].lowcost = w;
            }
        }
    }
    free(closedge);
    return sum;
}

/* test

输入数据:

7 11
A B 7
A D 5
B C 8
B D 9
B E 7
C E 5
D E 15
D F 6
E F 8
E G 9
F G 11

输出:

A - D : 5
D - F : 6
A - B : 7
B - E : 7
E - C : 5
E - G : 9
Total:39
*/
int main() {
    int i, j, k, m, n;
    char chx, chy;
    int cost;

    /* 读取节点和边的数目 */
    scanf("%d%d", &m, &n);
    getchar(); // 消耗回车键
    g.vertices_num = m;
    g.edges_num = n;
    for (i = 0; i < m; i++) g.vertices[i] = 'A' + i;

    /* 初始化图，所有节点间距离为无穷大 */
    for (i = 0; i < m; i++) {
        for (j = 0; j < m; j++) {
            g.matrix[i][j] = INT_MAX;
        }
    }

    /* 读取边信息 */
    for (k = 0; k < n; k++) {
        scanf("%c %c %d", &chx, &chy, &cost);
        getchar();
        i = chx - 'A';
        j = chy - 'A';
        g.matrix[i][j] = cost;
        g.matrix[j][i] = cost;
    }

    /* 求解最小生成树 */
    printf("Total:%d\n", mgraph_prim(&g));
    return 0;
}
\end{Codex}

\subsubsection{算法分析}
假设网中有$n$个顶点，则第一个进行初始化的循环语句的频度为$n$，第二个循环语句的频度为$n-1$。其中有两个内循环：其一是在\fn{closedge[v].lowcost}中求最小值，其频度为$n-1$；其二是重新选择具有最小代价的边，其频度为$n$。因此Prim算法的时间复杂度为$O(n^2)$，与网中边数无关，因此适用于求边稠密的图的最小生成树。

Prim算法的另一种实现是使用小根堆，其流程是：小根堆中存储一个端点在生成树中，另一个端点不在生成树的边，每次从小根堆的堆顶可选出权值最小的边$(u, v)$，将其从堆中推出，加入生成树中。然后将新出现的所有一个端点在生成树中，一个端点不在生成树的边都插入小根堆中。下一轮迭代中，下一条满足要求的边又上升到堆顶。如此重复$n-1$次，最后建立起该图的最小生成树。该算法的C代码实现如下。

\subsubsection{代码}

\begin{Codex}[label=mgraph_prim2.c]
#include <stdio.h>
#include <stdlib.h>  /* for malloc() */
#include <limits.h>  /* for INT_MAX */

/** 顶点数的最大值*/
#define MAX_VERTICES_NUM 100
/** 边的权值，对无权图，用0或1表示是否相邻；对有权图，则为权值. */
typedef int graph_weight_t;
/** 顶点信息，例如顶点名字. */
typedef char graph_vertex_t;

/**
 *@struct
 *@brief 邻接矩阵.
 */
typedef struct mgraph_t {
    int vertices_num; /* 顶点数*/
    int edges_num; /* 边数*/
    /* 顶点表，存放顶点的信息，如名字等*/
    graph_vertex_t vertices[MAX_VERTICES_NUM];
    /* 邻接矩阵，存放边的信息，如权重等*/
    graph_weight_t matrix[MAX_VERTICES_NUM][MAX_VERTICES_NUM];
    int directed; /* 图(网)的种类，1表示有向，0表示无向*/
} mgraph_t;

mgraph_t g;


/**
 * @struct 边
 */
typedef struct edge_t{
    int tail;  /** 弧尾, from */
    int head;  /** 弧头, to */
    graph_weight_t cost;  /** 权值 */
}edge_t;

static int edge_cmp(const edge_t *e1, const edge_t *e2) {
    const edge_t* const e11 = (const edge_t *)e1;
    const edge_t* const e22 = (const edge_t *)e2;
    return e11->cost - e22->cost;
}

typedef edge_t heap_elem_t; // 元素的类型

#include "heap.c"  // 等价于复制粘贴


/**
  * @brief Prim算法，求图的最小生成树.
  * @param[in] g 图对象的指针
  * @return MST的边的权值之和
  */
int mgraph_prim(const mgraph_t *g){
    graph_weight_t sum = 0; /* 权值之和 */
    int u = 0; /* 从0号顶点出发 */
    int i, count = 1;
    edge_t ed;
    heap_t h;
    const int n = g->vertices_num;
    /* 判断顶点是否已经加入最小生成树*/
    int* U = (int *)malloc(n * sizeof(int));
    for(i = 0; i < n; i++) U[i] = 0;
    heap_init(&h, g->edges_num, edge_cmp);

    /* 开始顶点加入U(所以count初始为1) */
    U[u] = 1;
    while (count < n) {
        int v;
        for(v = 0; v < n; v++) if(!U[v]) { /* 若v不在生成树，(u,v)加入堆*/
            ed.tail = u;
            ed.head = v;
            /* tail在树内，head不在树内*/
            ed.cost = g->matrix[u][v];
            heap_push(&h, ed);
        }
        while(!heap_empty(&h) && count < n) {
            /* 从堆中退出最小权值边，存入ed */
            ed = heap_top(&h); heap_pop(&h);
            if(!U[ed.head]) {
                /* 输出生成树TE的边，即此边加入TE */
                printf("%c - %c\n", g->vertices[ed.tail],
                        g->vertices[ed.head]);
                sum += g->matrix[ed.tail][ed.head];
                u = ed.head;
                /* u并入到生成树的顶点集合U */
                U[u] = 1;
                count++;
                break;
            }
        }
    }

    free(U);
    heap_uninit(&h);
    return sum;
}


// test，输入数据和main()函数与 mgraph_prim1.c 相同
// int main() {
// ...
\end{Codex}

\subsubsection{算法分析}
该算法迭代次数为$O(n)$，每次迭代将平均$e/n$条边插入最小堆中，$e$条边从堆中删除，堆的插入和删除操作时间复杂度均为$O(\log_2 e)$，则总的时间复杂度为 $O(e\log_2e)$。

\subsection{Kruskal算法}
假设连通网$N={V, E}$，则令最小生成树的初始状态为只有$n$个顶点而无边的非连通图$T=(V, {})$，图中每个顶点自成一个连通分量。在$E$中选择代价最小的边，若该边依附的顶点落在$T$中不同的连通分量上，则将此边加入到$T$中，否则舍去此边而选择下一条代价最小的边。依次类推，直至T中所有顶点都在同一连通分量上为止。

图\ref{fig:kruskal}所示为Kruskal算法构造一棵最小生成树的过程。

\begin{center}
\includegraphics[width=240pt]{kruskal1.png}\\
\includegraphics[width=240pt]{kruskal2.png}\\
\figcaption{Kruskal算法构造最小生成树的过程}\label{fig:kruskal}
\end{center}

下面是Kruskal算法的C语言实现。

\subsubsection{代码}

\begin{Codex}[label=mgraph_kruskal.c]
#include <stdio.h>
#include <stdlib.h>  /* for malloc() */
#include <limits.h>  /* for INT_MAX */

/************ 并查集 ************/
/**
  * @brief 初始化并查集.
  * @param[in] s 双亲表示法的数组
  * @param[in] n 数组s的元素个数
  * @return 无
  */
void ufs_init(int s[], int n) {
    int i;
    for(i = 0; i < n; i++) s[i] = -1;
}

/**
  * @brief Find操作，查找包含元素x的树的根.
  * @param[in] s 双亲表示法的数组
  * @param[in] x 要查找的元素
  * @return 包含元素x的树的根
  */
int ufs_find(const int s[], int x) {
    while(s[x] >= 0) {
        x = s[x];
    }
    return x;
}

 /*
  * @brief Union操作，求两个不相交集合的并集.
  * @param[in] s 双亲表示法的数组
  * @param[in] root1 一棵树的根
  * @param[in] root2 另一棵树的根
  * @return 无
  */
void ufs_union(int s[], int root1, int root2) {
    s[root1] += s[root2];
    s[root2] = root1;
}
/************ 并查集 ************/


/** 顶点数的最大值*/
#define MAX_VERTICES_NUM 100
/** 边的权值，对无权图，用0或1表示是否相邻；对有权图，则为权值. */
typedef int graph_weight_t;
#define INFINITY INT_MAX  /* 边权值无穷大 */
/** 顶点信息，例如顶点名字. */
typedef char graph_vertex_t;

/**
 *@struct
 *@brief 邻接矩阵.
 */
typedef struct mgraph_t {
    int vertices_num; /* 顶点数*/
    int edges_num; /* 边数*/
    /* 顶点表，存放顶点的信息，如名字等*/
    graph_vertex_t vertices[MAX_VERTICES_NUM];
    /* 邻接矩阵，存放边的信息，如权重等*/
    graph_weight_t matrix[MAX_VERTICES_NUM][MAX_VERTICES_NUM];
    int directed; /* 图(网)的种类，1表示有向，0表示无向*/
} mgraph_t;

mgraph_t g;


/**
 * @struct 边
 */
typedef struct edge_t{
    int tail;  /** 弧尾, from */
    int head;  /** 弧头, to */
    graph_weight_t cost;  /** 权值 */
}edge_t;

static int edge_cmp(const edge_t *e1, const edge_t *e2) {
    const edge_t* const e11 = (const edge_t *)e1;
    const edge_t* const e22 = (const edge_t *)e2;
    return e11->cost - e22->cost;
}

typedef edge_t heap_elem_t; // 元素的类型

#include "heap.c"  // 等价于复制粘贴


/*
  * @brief Kruskal算法，求图的最小生成树.
  * @param[in] g 图对象的指针
  * @return MST的边的权值之和
  */
int mgraph_kruskal(const mgraph_t *g) {
    graph_weight_t sum = 0;
    edge_t ed;
    int u, v, count;
    const int n = g->vertices_num;
    heap_t h;
    int *ufs;

    ufs = (int *)malloc(n * sizeof(int));
    ufs_init(ufs, n);
    heap_init(&h, g->edges_num, edge_cmp);

    /* 把所有边插入堆中*/
    for(u = 0; u < n; u++) {
        for(v = u + 1; v < n; v++) {
            const int w = g->matrix[u][v];
            if(w < INFINITY) {
                ed.tail = u;
                ed.head = v;
                ed.cost = w;
                heap_push(&h, ed);
            }
        }
    }

    count = 0; /* 最小生成树的边数*/
    while (count < n - 1)
    {
        /* 从堆中退出最小权值边，存入ed */
        ed = heap_top(&h);
        heap_pop(&h);
        /* 取两顶点所在集合的根*/
        u = ufs_find(ufs, ed.tail);
        v = ufs_find(ufs, ed.head);
        if(u != v) { /* 不是同一集合，说明不连通*/
            ufs_union(ufs, u, v); /* 合并，连通成一个分量*/
            /* 输出生成树TE的边，即此边加入TE */
            printf("%d - %d\n", ed.tail, ed.head);
            sum += ed.cost;
            count++;
        }
    }

    free(ufs);
    heap_uninit(&h);
    return sum;
}


// test，输入数据和main()函数与 mgraph_prim1.c 相同
// int main() {
// ...
\end{Codex}

\subsubsection{算法分析}
如果采用邻接矩阵作为图的存储结构，则在建立小根堆时需要检测图的邻接矩阵，这需要$O(n^2)$的时间。此外，需要将$e$条边组成初始的小根堆。如果直接从空堆开始，依次插入各边，需要$O(e\log_2e)$的时间。在构造最小生成树的过程中，需要进行$O(e)$次出堆操作\fn{heap_remove()}、$2e$次并查集的\fn{ufs_find()}操作以及$n-1$次\fn{ufs_union()}操作，计算时间分别为$O(e\log_2e)$、$O(\log_2n)$和$O(n)$，所以总时间为$O(n^2+e\log_2e)$。

如果采用邻接表作为图的存储结构，则在建立小根堆时需要检测图的邻接表，这需要$O(n+e)$的时间。为建成初始的小根堆，需要$O(e\log_2e)$的时间。在构造最小生成树的过程中，需要进行$O(e)$次出堆操作\fn{heap_remove()}、$2e$次并查集的\fn{ufs_find()}操作以及$n-1$次\fn{ufs_union()}操作，计算时间分别为$O(e\log_2e)$、$O(e\log_2n)$和$O(n)$，所以总时间为$O(n+e\log_2e)$。


\subsection{例题：POJ 1751 Highways}
\subsubsection{描述}
一个名叫Flatopia的岛国地势非常平坦。不幸的是Flatopia的公共高速公路系统很差劲。Flatopia的政府也意识到了这个问题，已经建造了许多高速公路用来连接比较重要的城镇。不过，仍然有一些城镇没有接入高速公路。因此，很有必要建造更多的高速公路，让任意两个城镇之间可以通过高速公路连接。

Flatopia的城镇从1到$N$编号，城镇i的位置由笛卡尔坐标$(x_i,y_i)$表示。每条高速公路仅连接两个城镇。所有的高速公路都是直线，因此它们的长度就等于两个城镇之间的欧氏距离。所有的高速公路是双向的，高速公路之间可以相交，但是司机只能在公路的端点（也即城镇）换道。

Flatopia政府希望能最小化建造高速公路的代价。由于Flatopia地势平坦，一条高速公路的代价正比于它的长度。因此，应该让高速公路的总长度最小。

\subsubsection{输入}
输入由两部分组成。第一部分描述所有的城镇，第二部分描述所有已经建造好的高速公路。

第一行包含一个整数$N(1 \leq N \leq 750)$，表示城镇的数目。接下来的$N$行每行包含一对整数，$x_i$和$y_i$，由空格隔开，表示第$i$个城镇的坐标。坐标的绝对值不会超过10000。每个城镇的坐标都不重叠。

接下来一行包含一个整数$M(0 \leq M \leq 1000)$，表示已经存在的高速公路的数目。接下来的$M$行每行包含一对整数，给出了一对城镇编号，表示这两个城镇被一条高速公路连接起来。每两个城镇之间最多被一条高速公路连接。

\subsubsection{输出}
输出所有需要新建的高速公路。每行一个高速公路，用一对城镇编号表示。

如果不需要新建高速公路，输出为空。

\subsubsection{样例输入}
\begin{Code}
9
1 5
0 0 
3 2
4 5
5 1
0 4
5 2
1 2
5 3
3
1 3
9 7
1 2
\end{Code}

\subsubsection{样例输出}
\begin{Code}
1 6
3 7
4 9
5 7
8 3
\end{Code}

\subsubsection{分析}
很明显，最小生成树。

题中的网络是一个完全图，任意两个城镇之间都有边，权值是两点间的距离。因此Prim算法比Kruskal算法效率更高。

对于已经存在的高速公路，令它们权值为0，可以保证它们一定会被选中。

因为题目只需要输出新建的高速公路的两个端点，不需要输出最小生成树的长度，所以计算距离的时候不用sqrt，也就不用double了。

\subsubsection{代码}
\begin{Codex}[label=poj_1751_highways_prim.c]
#include <stdio.h>
#include <stdlib.h>  /* for malloc() */
#include <limits.h>  /* for INT_MAX */

/** 顶点数的最大值*/
#define MAX_VERTICES_NUM 750
/** 边的权值，对无权图，用0或1表示是否相邻；对有权图，则为权值. */
typedef int graph_weight_t;
/** 顶点信息，例如顶点名字. */
typedef int graph_vertex_t;

/**
 *@struct
 *@brief 邻接矩阵.
 */
typedef struct mgraph_t {
    int vertices_num; /* 顶点数*/
    int edges_num; /* 边数*/
    /* 顶点表，存放顶点的信息，如名字等*/
    graph_vertex_t vertices[MAX_VERTICES_NUM];
    /* 邻接矩阵，存放边的信息，如权重等*/
    graph_weight_t matrix[MAX_VERTICES_NUM][MAX_VERTICES_NUM];
    int directed; /* 图(网)的种类，1表示有向，0表示无向*/
} mgraph_t;

mgraph_t g;

typedef struct closedge_t {
    int adjvex; /* 弧头，属于U */
    graph_weight_t lowcost; /* 边 adjvex->本下标 的权值，INT_MIN表示已经加入U */
} closedge_t;

/*
 * @brief 在V-E集合中寻找最小的边
 * @param[in] closedge MST中的边，起点为adjvex，终点为本下标
 * @param[in] n closedge数组的长度
 * @return 找到了则返回弧尾的下标，V-U为空集则返回-1，表示终止
 */
static int min_element(const closedge_t closedge[], int n) {
    int i;
    int min_value = INT_MAX;
    int min_loc = -1;
    for (i = 0; i < n; i++)
        if (closedge[i].lowcost > INT_MIN) {
            if (min_value > closedge[i].lowcost) {
                min_value = closedge[i].lowcost;
                min_loc = i;
            }
        }
    return min_loc;
}

/**
 * @brief Prim算法，求图的最小生成树.
 * @param[in] g 图对象的指针
 * @return MST的边的权值之和
 */
graph_weight_t mgraph_prim(const mgraph_t *g) {
    graph_weight_t sum = 0; /* 权值之和 */
    int i, j;
    int u = 0; /* 从0号顶点出发 */
    const int n = g->vertices_num;
    /* closedge[n]，记录从顶点集U到V-U的边*/
    closedge_t* const closedge = (closedge_t*) malloc(n * sizeof(closedge_t));

    /* 辅助数组初始化*/
    for (i = 0; i < n; i++) if (i != u) {
        closedge[i].adjvex = u;
        closedge[i].lowcost = g->matrix[u][i];
    }
    closedge[u].lowcost = INT_MIN; /* 初始, U={u} */

    for (i = 0; i < n; i++) if (i != u) { /* 其余的n-1个顶点*/
        /* 求出TE的下一个顶点k */
        const int k = min_element(closedge, n);
        /* 输出此边 closedge[k].adjvex --> k */
        if (g->matrix[closedge[k].adjvex][k] > 0)
            printf("%d %d\n", g->vertices[closedge[k].adjvex], g->vertices[k]);
        sum += g->matrix[closedge[k].adjvex][k];
        // sum += closedge[k].lowcost;  // 等价
        closedge[k].lowcost = INT_MIN;  /* 顶点k并入U，表示此边加入TE */
        /* 更新k的邻接点的值，不相邻为无穷大*/
        for (j = 0; j < n; j++) {
            const graph_weight_t w = g->matrix[k][j];
            if (w < closedge[j].lowcost) {
                closedge[j].adjvex = k;
                closedge[j].lowcost = w;
            }
        }
    }
    free(closedge);
    return sum;
}

/* 输入数据 */
int n, m, x[MAX_VERTICES_NUM], y[MAX_VERTICES_NUM];

/*
 * @brief 两点之间的距离.
 *
 * 因为题目只需要输出新建的高速公路的两个端点，不需要输出最小生成
 * 树的长度，所以计算距离的时候不用sqrt，也就不用double了。
 *
 * @param[in] i 编号为i+1的城镇
 * @param[in] j 编号为j+1的城镇
 *
 * @return 欧氏距离的平方
 */
static int distance(int i,int j) {
    return (x[i]-x[j]) * (x[i]-x[j]) + (y[i]-y[j]) * (y[i]-y[j]);
}

int main() {
    int i, j;
    scanf("%d",&n);
    g.vertices_num = n;
    g.edges_num = n * (n-1) / 2;
    g.directed = 0;
    for(i = 0; i < n; i++) g.vertices[i] = i+1;

    for(i = 0; i < n; i++) scanf("%d %d", &x[i], &y[i]);
    for(i = 0; i < n; i++)
        for(j = i; j < n; j++)
            g.matrix[i][j] = g.matrix[j][i] = distance(i,j);

    scanf("%d",&m);
    for(i = 0; i < m; i++) {
        int a, b;
        scanf("%d %d",&a, &b);
        g.matrix[a-1][b-1] = g.matrix[b-1][a-1] = 0;
    }

    mgraph_prim(&g);

    return 0;
}
\end{Codex}

\subsubsection{相关的题目}
与本题相同的题目：
\begindot
\item TODO
\myenddot

与本题相似的题目：
\begindot
\item POJ 2485 Highways, \myurl{http://poj.org/problem?id=2485}
\item POJ 1861 Network, \myurl{http://poj.org/problem?id=1861}
\item POJ 2395 Out of Hay, \myurl{http://poj.org/problem?id=2395}
\item POJ 2377 Bad Cowtractors, \myurl{http://poj.org/problem?id=2377}
\item POJ 2421 Constructing Roads, \myurl{http://poj.org/problem?id=2421}
\item POJ 1679 The Unique MST, \myurl{http://poj.org/problem?id=1679}
\item POJ 1258 Agri-Net, \myurl{http://poj.org/problem?id=1258}
\item POJ 1251 Jungle Roads, \myurl{http://poj.org/problem?id=1251}
\item POJ 3625 Building Roads, \myurl{http://poj.org/problem?id=3625}
\item POJ 1789 Truck History, \myurl{http://poj.org/problem?id=1789}
\myenddot


\section{最短路径} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{单源最短路径——Dijkstra算法}
\label{sec:dijkstra}

假设$S$为已求得最短路径的点的集合，则可证明：下一条最短路径（设其终点为$x$）或者是弧$(v, x)$，或者是中间只经过$S$中的顶点而最后到达顶点$x$的路径。

Dijkstra算法流程如下：
\begin{enumerate}
\item $S$为已找到从$v$出发的最短路径的终点的集合，它的初始状态为空集。\fn{dist[i]}存放的是$v$到$v_i$的最短路径长度，根据前面所述性质，\fn{dist[i]=min\{dist[i],weight(v,$v_i$)\}}。\fn{path[i]}存放的是最短路径上指向$v_i$的弧尾顶点。那么从$v$出发到图上其余$v_i$的最短路径长度的初值为：
$$
\text{dist}[i] = \text{weight}(v, v_i), v_i \in V
$$
\item 选择$v_j$，使得
$$
\text{dist}[j]=\min\left\{\text{dist}[j], \text{weight}(v, v_j)|v_j \in V-S\right\}
$$
将$v_j$加入到$S$，
$$
S = S \cup {v_j}
$$
\item 修改从$v$出发到集合$V-S$上任一顶点$v_k$可达的最短路径长度，并记录下这条边。
\begin{Code}
if(dist[j] + weight(j, k) < dist[k]) {
    dist[k] = dist[j] + weight(j, k);
    path[k] = j; /* 修改到k的最短路径 */
}
\end{Code}
\item 重复2，3共$n-1$次。
\end{enumerate}

例如，对图\ref{fig:dijkstra}所示的有向图及其邻接矩阵运行运行Dijkstra算法，

\begin{center}
\includegraphics[width=240pt]{dijkstra.png}\\
\figcaption{有向图及其邻接矩阵}\label{fig:dijkstra}
\end{center}

运算过程中$v_0$到其余个顶点的最短路近，\fn{dist[]}向量的变化情况如表\ref{tab:dijkstra}所示（从一列到下一列只需要更新新加入点的邻接点）。

\begin{center}
\tabcaption{Dijkstra算法过程中dist[]向量的变化情况}
\label{tab:dijkstra}
\begin{tabular}{|c|ccccc|}
\hline
\textbf{\textbf{终点}} & \textbf{i=1} & \textbf{i=2} & \textbf{i=3} & \textbf{i=4} & \textbf{i=5}\\
\hline
$v_1$ & $\infty$ & $\infty$ & $\infty$ & $\infty$ & $\infty$\\
\hline
\multirow{2}{*}{$v_2$} & \textbf{10}          & & & & \\
                       & $\mathbf{(v_0,v_2)}$ & & & & \\
\hline
\multirow{2}{*}{$v_3$} & $\infty$ &          60     &     \textbf{50}          & & \\
                       &          & $(v_0,v_2,v_3)$ & $\mathbf{(v_0,v_4,v_5)}$ & & \\
\hline
\multirow{2}{*}{$v_4$} &     30      &      \textbf{30}     & & & \\
                       & $(v_0,v_4)$ & $\mathbf{(v_0,v_4)}$ & & & \\
\hline
\multirow{2}{*}{$v_5$} &     100     &     100     &       90        &         \textbf{60}          & \\
                       & $(v_0,v_5)$ & $(v_0,v_5)$ & $(v_0,v_4,v_5)$ & $\mathbf{(v_0,v_4,v_3,v_5)}$ & \\
\hline
$v_j$ & $v_2$ & $v_4$ & $v_3$ & $v_5$ & \\
\hline
$S$ & $(v_0,v_2)$ & $(v_0,v_2,v_4)$ & $(v_0,v_2,v_3,v_4)$ & $(v_0,v_2,v_3,v_4,v_5)$ & \\
\hline
\end{tabular}
\end{center}

Dijkstra算法的C语言实现如下。

\subsubsection{代码}

\begin{Codex}[label=mgraph_dijkstra.c]
#include <stdio.h>
#include <stdlib.h>  /* for malloc() */
#include <limits.h>  /* for INT_MAX */

/** 顶点数的最大值*/
#define MAX_VERTICES_NUM 100
/** 边的权值，对无权图，用0或1表示是否相邻；对有权图，则为权值. */
typedef int graph_weight_t;
#define GRAPH_INFINITY INT_MAX
/** 顶点信息，例如顶点名字. */
typedef char graph_vertex_t;

/**
 *@struct
 *@brief 邻接矩阵.
 */
typedef struct mgraph_t {
    int vertices_num; /* 顶点数*/
    int edges_num; /* 边数*/
    /* 顶点表，存放顶点的信息，如名字等*/
    graph_vertex_t vertices[MAX_VERTICES_NUM];
    /* 邻接矩阵，存放边的信息，如权重等*/
    graph_weight_t matrix[MAX_VERTICES_NUM][MAX_VERTICES_NUM];
    int directed; /* 图(网)的种类，1表示有向，0表示无向*/
} mgraph_t;

mgraph_t g;

/** path[i]存放的是最短路径上指向vi的弧尾顶点 */
int path[MAX_VERTICES_NUM];
/** dist[i]存放的是v到vi的最短路径长度 */
int dist[MAX_VERTICES_NUM];


/*
  * @brief Dijkstra算法求单源最短路径.
  * @param[in] g 图对象的指针
  * @param[in] v 起点
  * @param[out] dist dist[i]存放的是v到vi的最短路径长度
  * @param[out] path path[i]存放的是最短路径上指向vi的弧尾顶点
  * @return 无
  */
void mgraph_dijkstra(const mgraph_t *g, int v, int dist[], int path[]) {
    int i, j;
    const int n = g->vertices_num;

    // 初始化S集合
    int *S = (int*)malloc( n * sizeof(int));
    for(i = 0; i < n; i++) S[i] = 0;
    S[v] = 1; /* 初始化，顶点u加入S */

    // 初始化dist和path
    for(i = 0; i < n; i++) if (i !=v) {
        dist[i] = g->matrix[v][i];
        if(dist[i] < GRAPH_INFINITY) {
            path[i] = v;
        }  else {
            path[i] = -1; /* 没有顶点指向i */
        }
    }
    dist[v] = 0;
    path[v] = -1;

    for(i = 0; i < n; i++) if (i !=v) {
        /* 选不在S中的最短路径顶点 u */
        int u;
        graph_weight_t min = GRAPH_INFINITY;
        for(j = 0; j < n; j++) {
            if(!S[j] && dist[j] < min) {
                u = j;
                min = dist[j];
            }
        }
        S[u] = 1;
        for(j = 0; j < n; j++) {
            const graph_weight_t w = g->matrix[u][j];
            /* 顶点j未就加入S，且经过u到j可缩短路径*/
            if(!S[j] && w < GRAPH_INFINITY &&
                dist[u] + w < dist[j]) {
                dist[j] = dist[u] + w;
                path[j] = u; /* 修改到j的最短路径*/
            }
        }
    }
    free(S);
}

/*
 * @brief 打印从起点到v的最短路径
 * @param[in] v 终点
 * @param[in] path Dijkstra计算好的path
 * @return 无
 */
static void print_path_r(int v, const int path[]) {
    if (path[v] == -1) {
        printf("%c", g.vertices[v]);
    } else {
        print_path_r(path[v], path);
        printf("->%c", g.vertices[v]);
    }
}

/**
 * @brief 打印 u到其他所有点的最短路径
 * @param[in] path Dijkstra计算好的path
 * @param[in] n path的长度
 * @return 无
 */
void print_path(const int path[], int n) {
    int i;
    for (i = 0; i < n; i++) if (path[i] != -1) {
        print_path_r(i, path);
        printf("\n");
    }
}


/* test

输入数据:

6 8
A C 10
A E 30
A F 100
B C 5
C D 50
D 5 10
E D 20
E F 60

输出:

A->C
A->E->D
A->E
A->E->F
*/
int main() {
    int i, j, k;
    char chx, chy;
    graph_weight_t cost;

    /* 读取节点和边的数目 */
    scanf("%d%d", &(g.vertices_num), &(g.edges_num));
    g.directed = 1;
    for (i = 0; i < g.vertices_num; i++) g.vertices[i] = 'A' + i;

    /* 初始化图，所有节点间距离为无穷大 */
    for (i = 0; i < g.vertices_num; i++) {
        for (j = 0; j < g.vertices_num; j++) {
            g.matrix[i][j] = GRAPH_INFINITY;
        }
    }

    /* 读取边信息 */
    getchar(); // 消耗回车键
    for (k = 0; k < g.edges_num; k++) {
        scanf("%c %c %d", &chx, &chy, &cost);
        getchar();
        i = chx - 'A';
        j = chy - 'A';
        g.matrix[i][j] = cost;
    }

    /* 求 V0 到其他所有顶点的最短路径 */
    mgraph_dijkstra(&g, 0, dist, path);
    print_path(path, g.vertices_num);
    return 0;
}
\end{Codex}

\subsubsection{算法分析}
该算法包含了两个并列的for循环，第一个for循环做辅助数组的初始化工作，计算时间为$O(n)$，第二个for循环是二重嵌套循环，进行最短路径的求解工作，由于对图中几乎每个顶点都要做计算，每个顶点的又要对集合S内的顶点进行检测，对集合$V-S$内中的顶点进行修改，所以运算时间复杂度为$O(n^2)$。算法总的时间复杂度为$O(n^2)$。


\subsection{每点最短路径——Floyd算法}
Floyd算法的基本思想是：假设求从定点$v_i$到$v_j$的最短路径。初始时，若$v_i$与$v_j$之间存在边，则最短路径长度为此边的权值；若不存在边，则最短路径长度为无穷大。以后逐步在路径中加入顶点$k(k=0,1,...,n-1)$作为中间顶点，如果加入中间顶点后，得到的路径比原来的路径长度减少了，则以新路径代替原路径。

首先比较$(v_i,v_j)$和$(v_i,v_0,v_j)$的路径长度，取较短者为从$v_i$到$v_j$的中间顶点的序号不大于0的最短路径。如果$(v_i,v_0,v_j)$较短，则取$(v_i,v_0,v_j)$作为最短路径。假如在路径上再增加一个顶点$v_1$，也就是说，如果$(v_i,...,v_1)$和$(v_1,...,v_j)$分别是当前找到的中间定点的序号不大于0的最短路径，那么$(vi,...,v1,...,vj)$就有可能是从$v_i$到$v_j$的中间顶点的序号不大于1的最短路径，将它和已经得到的从$v_i$到$v_j$的中间顶点的序号不大于0的最短路径相比较，选出较短者作为从$v_i$到$v_j$的中间顶点的序号不大于1的最短路径。再增加一个顶点$v_2$，继续进行试探，依此类推。一般的，若$(v_i,...,v_k)$和$(v_k,...,v_j)$分别是从$v_i$到$v_k$和从$v_k$到$v_j$的中间定点的序号不大于$k-1$的最短路径，则将$(v_i,...,v_k,...,v_j)$和已经得到的从$v_i$到$v_j$的中间顶点的序号不大于$k-1$的最短路径相比，较短者便是从$v_i$到$v_j$的中间顶点的序号不大于$k$的最短路径。这样，在经过$n$次比较后，最后求得的必是从$v_i$到$v_j$的最短路径。

现定义一个$n$阶方阵序列，
$$
D^{(-1)}, D^{(0)} , D^{(1)},..., , D^{(k)},..., , D^{(n-1)}
$$
其中，
\begin{eqnarray}
D^{(-1)}[i][j] &=& \text{g->matrix}[i][j],  \nonumber \\
D^{(k)}[i][j] &=& \min\left\{D^{(k-1)}[i][j], D^{(k-1)}[i][k] + D^{(k-1)}[k][j]\right\},0 \leq k \leq n-1 \nonumber
\end{eqnarray}

上述公式中，$D^{(k)}[i][j]$是从$v_i$到$v_j$的中间顶点的序号不大于$k$的最短路径的长度；$D^{(n-1)}[i][j]$是从$v_i$到$v_j$的最短路径的长度。

例如，对图\ref{fig:floyd}所示的有向图及其邻接矩阵运行Floyd算法，

\begin{center}
\includegraphics[width=180pt]{floyd.png}\\
\figcaption{有向图及其邻接矩阵}\label{fig:floyd}
\end{center}

运算过程中矩阵D的变化如表\ref{tab:floyd}所示。

\begin{center}
\tabcaption{Floyd算法过程中方阵和最短路径的变化}
\label{tab:floyd}
\begin{tabular}{|c|ccc|ccc|ccc|ccc|}
\hline
\multirow{2}{*}{$\mathbf{D}$} & \multicolumn{3}{|c|}{$\mathbf{D^{(0)}}$} & \multicolumn{3}{|c|}{$\mathbf{D^{(1)}}$} & \multicolumn{3}{|c|}{$\mathbf{D^{(2)}}$} & \multicolumn{3}{|c|}{$\mathbf{D^{(3)}}$} \\
 & 0 & 1 & 2 & 0 & 1 & 2 & 0 & 1 & 2 & 0 & 1 & 2 \\
\hline
0 & 0 & 4 & 11 & 0 & 4 & 11 & 0 & 4 & 6 & 0 & 4 & 6 \\
1 & 6 & 0 & 2 & 6 & 0 & 2 & 6 & 0 & 2 & 5 & 0 & 2 \\
2 & 3 & $\infty$ & 0 & 3 & 7 & 0 & 3 & 7 & 0 & 3 & 7 & 0 \\
\hline
\multirow{2}{*}{$\mathbf{P}$} & \multicolumn{3}{|c|}{$\mathbf{P^{(0)}}$} & \multicolumn{3}{|c|}{$\mathbf{P^{(1)}}$} & \multicolumn{3}{|c|}{$\mathbf{P^{(2)}}$} & \multicolumn{3}{|c|}{$\mathbf{P^{(3)}}$} \\
 & 0 & 1 & 2 & 0 & 1 & 2 & 0 & 1 & 2 & 0 & 1 & 2 \\
\hline
\multirow{2}{*}{0} & & A & A & & AB & A & & AB & AB & & AB & AB \\
                   & & B & C & & & C & & & C & & & C \\
\hline
\multirow{2}{*}{1} & B & & B & B & & B & B & & BC & BC & & BC \\
                   & A & & C & A & & C & A & & & A & & \\
\hline
\multirow{2}{*}{2} & C & & & C & CA & & C & CA & & CA & CA & \\
                   & A & & & A & B & & A & B & & & B & \\
\hline
\end{tabular}
\end{center}

Floyd算法的C语言实现如下。

\subsubsection{代码}

\begin{Codex}[label=mgraph_floyd.c]
#include <stdio.h>
#include <stdlib.h>  /* for malloc() */
#include <limits.h>  /* for INT_MAX */

/** 顶点数的最大值*/
#define MAX_VERTICES_NUM 100
/** 边的权值，对无权图，用0或1表示是否相邻；对有权图，则为权值. */
typedef int graph_weight_t;
#define GRAPH_INFINITY (INT_MAX / 2)   /* 确保加法不溢出 */
/** 顶点信息，例如顶点名字. */
typedef char graph_vertex_t;

/**
 *@struct
 *@brief 邻接矩阵.
 */
typedef struct mgraph_t {
    int vertices_num; /* 顶点数*/
    int edges_num; /* 边数*/
    /* 顶点表，存放顶点的信息，如名字等*/
    graph_vertex_t vertices[MAX_VERTICES_NUM];
    /* 邻接矩阵，存放边的信息，如权重等*/
    graph_weight_t matrix[MAX_VERTICES_NUM][MAX_VERTICES_NUM];
    int directed; /* 图(网)的种类，1表示有向，0表示无向*/
} mgraph_t;


mgraph_t g;
/** dist[i][j]是顶点i和j之间最短路径长度 */
graph_weight_t dist[MAX_VERTICES_NUM][MAX_VERTICES_NUM];
/** path[i][j]是最短路径上i和j之间的顶点 */
int path[MAX_VERTICES_NUM][MAX_VERTICES_NUM];


/*
  * @brief Floyd算法求每点之间最短路径.
  * @param[in] g 图对象的指针
  * @param[out] dist dist[i][j]是顶点i和j之间最短路径长度
  * @param[out] path path[i][j]是最短路径上i和j之间的顶点
  * @return 无
  */
void mgraph_floyd(const mgraph_t *g,
       int dist[][MAX_VERTICES_NUM],
       int path[][MAX_VERTICES_NUM]) {
    int i, j, k;
    const int n = g->vertices_num;

    for(i = 0; i < n; i++) {
        for(j = 0; j < n; j++) {
            if(i != j) {
                dist[i][j] = g->matrix[i][j];
                path[i][j] = i;
            } else {
                dist[i][j] = 0;
                path[i][j] = -1;
            }
        }
    }
    for(k = 0; k < n; k++) {
        for(i = 0; i < n; i++) {
            for(j = 0; j < n; j++) {
                /* i到j的路径上加入顶点k可以缩短路径长度*/
                if(dist[i][k] + dist[k][j] < dist[i][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                    path[i][j] = k;
                }
            }
        }
    }
}

/*
 * @brief 打印从u到v的最短路径
 * @param[in] u 起点
 * @param[in] v 终点
 * @param[in] path Floyd 计算好的path
 * @return 无
 */
static void print_path_r(int u, int v, const int path[][MAX_VERTICES_NUM]) {
    if (path[u][v] == -1) {
        printf("%c", g.vertices[u]);
    } else {
        print_path_r(u, path[u][v], path);
        printf("->%c", g.vertices[v]);
    }
}

/**
 * @brief 打印 u到其他所有点的最短路径
 * @param[in] path Dijkstra计算好的path
 * @param[in] n path的长度
 * @return 无
 */
void print_path(const mgraph_t *g, const int path[][MAX_VERTICES_NUM]) {
    int i, j;
    for (i = 0; i < g->vertices_num; i++) {
        for (j = 0; j < g->vertices_num; j++) {
            if (i != j) {
                print_path_r(i, j, path);
                printf("\n");
            }
        }
        printf("\n");
    }
}


/* test

输入数据:

3 5
A B 4
A C 11
B A 6
B C 2
C A 3

输出:

A->B
A->B->C

B->C->A
B->C

C->A
C->A->B
*/
int main() {
    int i, j, k;
    char chx, chy;
    graph_weight_t cost;

    /* 读取节点和边的数目 */
    scanf("%d%d", &(g.vertices_num), &(g.edges_num ));
    g.directed = 1;
    for (i = 0; i < g.vertices_num; i++) g.vertices[i] = 'A' + i;

    /* 初始化图，所有节点间距离为无穷大 */
    for (i = 0; i < g.vertices_num; i++) {
        for (j = 0; j < g.vertices_num; j++) {
            g.matrix[i][j] = GRAPH_INFINITY;
        }
    }

    /* 读取边信息 */
    getchar(); // 消耗回车键
    for (k = 0; k < g.edges_num ; k++) {
        scanf("%c %c %d", &chx, &chy, &cost);
        getchar();
        i = chx - 'A';
        j = chy - 'A';
        g.matrix[i][j] = cost;
    }

    /* 求两两之间的最短路径 */
    mgraph_floyd(&g, dist, path);
    print_path(&g, path);
    return 0;
}
\end{Codex}

\subsubsection{算法分析}
该算法中有两个并列的for循环，第一个循环是个二重循环，用于初始化方阵$D$；第二个循环是个三重循环，逐步生成$D^{(0)}, D^{(1)} ,...,D^{(n-1)}$。所以算法总的时间复杂度为$O(n^3)$。

Dijkstra算法权值不能为负，Floyd权值可以为负，但环路之和不能为负。


\subsection{例题：HDU 2544 最短路}
\subsubsection{描述}
在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t-shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场的时候，却是非常累的！所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮助他们吗？

\subsubsection{输入}
输入包括多组数据。每组数据第一行是两个整数$N,M(N \leq 100,M \leq 10000)$，$N$表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为$N$的路口是赛场所在地，$M$则表示在成都有几条路。$N=M=0$表示输入结束。接下来$M$行，每行包括3个整数$A,B,C(1 \leq A,B \leq N,1 \leq C \leq 1000)$,表示在路口$A$与路口$B$之间有一条路，我们的工作人员需要$C$分钟的时间走过这条路。
输入保证至少存在1条商店到赛场的路线。

\subsubsection{输出}
对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间

\subsubsection{样例输入}
\begin{Code}
2 1
1 2 3
3 3
1 2 5
2 3 5
3 1 2
0 0
\end{Code}

\subsubsection{样例输出}
\begin{Code}
3
2
\end{Code}

\subsubsection{分析}
单源最短路径，用Dijkstra算法，将第\S\ref{sec:dijkstra}节中的代码稍加修改即可。

注意，街道是双向的，所以给边赋值时要对称赋值。

\subsubsection{代码}
\begin{Codex}[label=hdu_2544.c]
/* http://acm.hdu.edu.cn/showproblem.php?pid=2544 */
#include <stdio.h>
#include <stdlib.h>  /* for malloc() */
#include <limits.h>  /* for INT_MAX */

/** 顶点数的最大值*/
#define MAX_VERTICES_NUM 100
/** 边的权值，对无权图，用0或1表示是否相邻；对有权图，则为权值. */
typedef int graph_weight_t;
#define GRAPH_INFINITY INT_MAX
/** 顶点信息，例如顶点名字. */
typedef char graph_vertex_t;

/**
 *@struct
 *@brief 邻接矩阵.
 */
typedef struct mgraph_t {
    int vertices_num; /* 顶点数*/
    int edges_num; /* 边数*/
    /* 顶点表，存放顶点的信息，如名字等*/
    graph_vertex_t vertices[MAX_VERTICES_NUM];
    /* 邻接矩阵，存放边的信息，如权重等*/
    graph_weight_t matrix[MAX_VERTICES_NUM][MAX_VERTICES_NUM];
    int directed; /* 图(网)的种类，1表示有向，0表示无向*/
} mgraph_t;

mgraph_t g;

/** path[i]存放的是最短路径上指向vi的弧尾顶点 */
int path[MAX_VERTICES_NUM];
/** dist[i]存放的是v到vi的最短路径长度 */
int dist[MAX_VERTICES_NUM];


/*
  * @brief Dijkstra算法求单源最短路径.
  * @param[in] g 图对象的指针
  * @param[in] v 起点
  * @param[out] dist dist[i]存放的是v到vi的最短路径长度
  * @param[out] path path[i]存放的是最短路径上指向vi的弧尾顶点
  * @return 无
  */
void mgraph_dijkstra(const mgraph_t *g, int v, int dist[], int path[]) {
    int i, j;
    const int n = g->vertices_num;

    // 初始化S集合
    int *S = (int*)malloc( n * sizeof(int));
    for(i = 0; i < n; i++) S[i] = 0;
    S[v] = 1; /* 初始化，顶点u加入S */

    // 初始化dist和path
    for(i = 0; i < n; i++) if (i !=v) {
        dist[i] = g->matrix[v][i];
        if(dist[i] < GRAPH_INFINITY) {
            path[i] = v;
        }  else {
            path[i] = -1; /* 没有顶点指向i */
        }
    }
    dist[v] = 0;
    path[v] = -1;

    for(i = 0; i < n; i++) if (i !=v) {
        /* 选不在S中的最短路径顶点 u */
        int u;
        graph_weight_t min = GRAPH_INFINITY;
        for(j = 0; j < n; j++) {
            if(!S[j] && dist[j] < min) {
                u = j;
                min = dist[j];
            }
        }
        S[u] = 1;
        for(j = 0; j < n; j++) {
            const graph_weight_t w = g->matrix[u][j];
            /* 顶点j未就加入S，且经过u到j可缩短路径*/
            if(!S[j] && w < GRAPH_INFINITY &&
                dist[u] + w < dist[j]) {
                dist[j] = dist[u] + w;
                path[j] = u; /* 修改到j的最短路径*/
            }
        }
    }
    free(S);
}

int main() {
    int i, j, k;
    int x, y;
    graph_weight_t cost;

    /* 读取节点和边的数目 */
    while(scanf("%d%d", &(g.vertices_num), &(g.edges_num)) > 0)
        if (g.vertices_num > 0 && g.edges_num > 0){
        g.directed = 1;
        for (i = 0; i < g.vertices_num; i++) g.vertices[i] = '1' + i;

        /* 初始化图，所有节点间距离为无穷大 */
        for (i = 0; i < g.vertices_num; i++) {
            for (j = 0; j < g.vertices_num; j++) {
                g.matrix[i][j] = GRAPH_INFINITY;
            }
        }

        /* 读取边信息 */
        for (k = 0; k < g.edges_num; k++) {
            scanf("%d %d %d", &x, &y, &cost);
            i = x - 1;
            j = y - 1;
            g.matrix[i][j] = cost;
            g.matrix[j][i] = cost;  // 注意，街道是双向的
        }

        /* 求 商店（即路口1） 到其他所有顶点的最短路径 */
        mgraph_dijkstra(&g, 0, dist, path);
        /* 打印商店（即路口1）到赛场（即路口N）的最短路径长度 */
        printf("%d\n", dist[g.vertices_num-1]);
    }
    return 0;
}
\end{Codex}

\subsubsection{相关的题目}
与本题相同的题目：
\begindot
\item HDU 2544 最短路, \myurl{http://acm.hdu.edu.cn/showproblem.php?pid=2544}
\myenddot

与本题相似的题目：
\begindot
\item POJ 2253 Frogger, \myurl{http://poj.org/problem?id=2253}
\item POJ 3268 Silver Cow Party, \myurl{http://poj.org/problem?id=3268}
\item POJ 1797 Heavy Transportation, \myurl{http://poj.org/problem?id=1797}
\item POJ 1847 Tram, \myurl{http://poj.org/problem?id=1847}
\myenddot


\subsection{例题：POJ 1125 Stockbroker Grapevine}
\subsubsection{描述}
Stockbrokers are known to overreact to rumours. You have been contracted to develop a method of spreading disinformation amongst the stockbrokers to give your employer the tactical edge in the stock market. For maximum effect, you have to spread the rumours in the fastest possible way. 

Unfortunately for you, stockbrokers only trust information coming from their "Trusted sources" This means you have to take into account the structure of their contacts when starting a rumour. It takes a certain amount of time for a specific stockbroker to pass the rumour on to each of his colleagues. Your task will be to write a program that tells you which stockbroker to choose as your starting point for the rumour, as well as the time it will take for the rumour to spread throughout the stockbroker community. This duration is measured as the time needed for the last person to receive the information.

\subsubsection{输入}
Your program will input data for different sets of stockbrokers. Each set starts with a line with the number of stockbrokers. Following this is a line for each stockbroker which contains the number of people who they have contact with, who these people are, and the time taken for them to pass the message to each person. The format of each stockbroker line is as follows: The line starts with the number of contacts ($n$), followed by n pairs of integers, one pair for each contact. Each pair lists first a number referring to the contact (e.g. a '1' means person number one in the set), followed by the time in minutes taken to pass a message to that person. There are no special punctuation symbols or spacing rules. 

Each person is numbered 1 through to the number of stockbrokers. The time taken to pass the message on will be between 1 and 10 minutes (inclusive), and the number of contacts will range between 0 and one less than the number of stockbrokers. The number of stockbrokers will range from 1 to 100. The input is terminated by a set of stockbrokers containing 0 (zero) people. 

\subsubsection{输出}
For each set of data, your program must output a single line containing the person who results in the fastest message transmission, and how long before the last person will receive any given message after you give it to this person, measured in integer minutes. 

It is possible that your program will receive a network of connections that excludes some persons, i.e. some people may be unreachable. If your program detects such a broken network, simply output the message "disjoint". Note that the time taken to pass the message from person A to person B is not necessarily the same as the time taken to pass it from B to A, if such transmission is possible at all.

\subsubsection{样例输入}
\begin{Code}
3
2 2 4 3 5
2 1 2 3 6
2 1 2 2 2
5
3 4 4 2 8 5 3
1 5 8
4 1 6 4 10 2 7 5 2
0
2 2 5 1 5
0
\end{Code}

\subsubsection{样例输出}
\begin{Code}
3 2
3 10
\end{Code}

\subsubsection{分析}

\subsubsection{代码}
\begin{Codex}[label=poj_1125.c]
/* http://poj.org/problem?id=1125 */
#include <stdio.h>
#include <stdlib.h>  /* for malloc() */
#include <limits.h>  /* for INT_MAX */

/** 顶点数的最大值*/
#define MAX_VERTICES_NUM 100
/** 边的权值，对无权图，用0或1表示是否相邻；对有权图，则为权值. */
typedef int graph_weight_t;
#define GRAPH_INFINITY (INT_MAX / 2)   /* 确保加法不溢出 */
/** 顶点信息，例如顶点名字. */
typedef char graph_vertex_t;

/**
 *@struct
 *@brief 邻接矩阵.
 */
typedef struct mgraph_t {
    int vertices_num; /* 顶点数*/
    int edges_num; /* 边数*/
    /* 顶点表，存放顶点的信息，如名字等*/
    graph_vertex_t vertices[MAX_VERTICES_NUM];
    /* 邻接矩阵，存放边的信息，如权重等*/
    graph_weight_t matrix[MAX_VERTICES_NUM][MAX_VERTICES_NUM];
    int directed; /* 图(网)的种类，1表示有向，0表示无向*/
} mgraph_t;


mgraph_t g;
/** dist[i][j]是顶点i和j之间最短路径长度 */
graph_weight_t dist[MAX_VERTICES_NUM][MAX_VERTICES_NUM];
/** path[i][j]是最短路径上i和j之间的顶点 */
int path[MAX_VERTICES_NUM][MAX_VERTICES_NUM];
/** 存放每个点的最短路径的最长者 */
graph_weight_t max_len[MAX_VERTICES_NUM];

/*
  * @brief Floyd算法求每点之间最短路径.
  * @param[in] g 图对象的指针
  * @param[out] dist dist[i][j]是顶点i和j之间最短路径长度
  * @param[out] path path[i][j]是最短路径上i和j之间的顶点
  * @return 无
  */
void mgraph_floyd(const mgraph_t *g,
       int dist[][MAX_VERTICES_NUM],
       int path[][MAX_VERTICES_NUM]) {
    int i, j, k;
    const int n = g->vertices_num;

    for(i = 0; i < n; i++) {
        for(j = 0; j < n; j++) {
            if(i != j) {
                dist[i][j] = g->matrix[i][j];
                path[i][j] = i;
            } else {
                dist[i][j] = 0;
                path[i][j] = -1;
            }
        }
    }
    for(k = 0; k < n; k++) {
        for(i = 0; i < n; i++) {
            for(j = 0; j < n; j++) {
                /* i到j的路径上加入顶点k可以缩短路径长度*/
                if(dist[i][k] + dist[k][j] < dist[i][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                    path[i][j] = k;
                }
            }
        }
    }
}

static int max_element(const graph_weight_t w[], int begin, int end) {
    int i;
    int max_value = INT_MIN;
    int max_pos = -1;
    for (i = begin; i < end; i++) {
        if (max_value < w[i]) {
            max_value = w[i];
            max_pos = i;
        }
    }
    return max_pos;
}

static int min_element(const graph_weight_t w[], int begin, int end) {
    int i;
    int min_value = INT_MAX;
    int min_pos = -1;
    for (i = begin; i < end; i++) {
        if (min_value > w[i]) {
            min_value = w[i];
            min_pos = i;
        }
    }
    return min_pos;
}
int main() {
    int i, j;
    int min_pos;

    /* 读取顶点数 */
    while (scanf("%d", &(g.vertices_num)) > 0 && g.vertices_num > 0) {
        g.edges_num = 0;
        g.directed = 1;
        for (i = 0; i < g.vertices_num; i++) g.vertices[i] = '1' + i;

        /* 初始化图，所有节点间距离为无穷大 */
        for (i = 0; i < g.vertices_num; i++) {
            for (j = 0; j < g.vertices_num; j++) {
                g.matrix[i][j] = GRAPH_INFINITY;
            }
        }

        /* 读取边信息 */
        for (i = 0; i < g.vertices_num; i++) {
            int m;
            graph_weight_t cost;
            scanf("%d", &m);
            g.edges_num += m;
            while (m--) {
                scanf("%d %d", &j, &cost);
                --j;
                g.matrix[i][j] = cost;
            }
        }

        /* 求两两之间的最短路径 */
        mgraph_floyd(&g, dist, path);

        /* 找最短路径的最长着 */
        for (i = 0; i < g.vertices_num; i++) {
            max_len[i] = dist[i][max_element(dist[i], 0, g.vertices_num)];
        }
        /* 找 max_len 的最小者　*/
        min_pos = min_element(max_len, 0, g.vertices_num);

        if (max_len[min_pos] == GRAPH_INFINITY) {
            printf("disjoint\n");
        } else {
            printf("%d %d\n", min_pos+1, max_len[min_pos]);
        }
    }
    return 0;
}
\end{Codex}

\subsubsection{相关的题目}
与本题相同的题目：
\begindot
\item POJ 1125 Stockbroker Grapevine, \myurl{http://poj.org/problem?id=1125}
\myenddot

与本题相似的题目：
\begindot
\item POJ 3615 Cow Hurdles, \myurl{http://poj.org/problem?id=3615}
\item POJ 3660 Cow Contest, \myurl{http://poj.org/problem?id=3660}
\item POJ 2502 Subway, \myurl{http://poj.org/problem?id=2502}
\item HDU 3631 Shortest Path, \myurl{http://acm.hdu.edu.cn/showproblem.php?pid=3631}
\myenddot


\section{拓扑排序} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
由某个集合上的一个偏序得到该集合上的一个全序，这个操作称为\textbf{拓扑排序}。

拓扑序列的特点是：若有向边$<V_i, V_j>$是途中的弧，则在序列中顶点$V_i$必须排在顶点$V_j$之前。

如果用有向图表示一个工程，顶点表示活动，用有向边$<v_i,v_j>$表示活动必须先于活动进行。这种有向图叫做顶点表示活动的网络(Activity On Vertext Network)，简称\textbf{AOV网络}。

检测AOV网络是否存在环的方法是对AOV网络构造其顶点的拓扑有序序列。拓扑排序的基本步骤是：
\begin{enumerate}
\item 在有向图中选一个没有前驱的顶点且输出之；
\item 从图中删除该顶点和所有以它为尾的弧线。
\end{enumerate}
重复以上两步，直至全部顶点输出，或当前图中不存在无前驱的顶点为止（这种情况说明图中存在环）。

拓扑排序的C语言实现如下。

\subsubsection{代码}

\begin{Codex}[label=mgraph_topological_sort.c]
#include <stdio.h>
#include <stdlib.h>  /* for malloc() */
#include <limits.h>  /* for INT_MAX */

/** 顶点数的最大值*/
#define MAX_VERTICES_NUM 100
/** 边的权值，对无权图，用0或1表示是否相邻；对有权图，则为权值. */
typedef int graph_weight_t;
#define GRAPH_INFINITY INT_MAX
/** 顶点信息，例如顶点名字. */
typedef char graph_vertex_t;

/**
 *@struct
 *@brief 邻接矩阵.
 */
typedef struct mgraph_t {
    int vertices_num; /* 顶点数*/
    int edges_num; /* 边数*/
    /* 顶点表，存放顶点的信息，如名字等*/
    graph_vertex_t vertices[MAX_VERTICES_NUM];
    /* 邻接矩阵，存放边的信息，如权重等*/
    graph_weight_t matrix[MAX_VERTICES_NUM][MAX_VERTICES_NUM];
    int directed; /* 图(网)的种类，1表示有向，0表示无向*/
} mgraph_t;

mgraph_t g;
int topological[MAX_VERTICES_NUM];


#include "stack.c"    // 等价于复制粘贴


/*
  * @brief 拓扑排序.
  * @param[in] g 图对象的指针
  * @param[out] topological 保存拓扑排序的结果
  * @return 无环返回 1，有环返回 0
  */
int mgraph_topological_sort(const mgraph_t *g, int topological[]) {
    int i, j, u;
    int count = 0; /* 拓扑序列的元素个数*/
    const int n = g->vertices_num;
    /* in_degree[i]是顶点i的入度 */
    int *in_degree = (int*)malloc(n * sizeof(int));
    stack_t s;

    memset(in_degree, 0, n * sizeof(int));
    for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++) {
            if (g->matrix[i][j] < GRAPH_INFINITY)
                in_degree[j]++;
        }
    }

    stack_init(&s, n * sizeof(int));
    for(i = 0; i < n; i ++) {
        if(in_degree[i] == 0)
            stack_push(&s, i);
    }

    while(!stack_empty(&s)) {
        u = stack_top(&s); stack_pop(&s);
        topological[count++] = u;
        for (i = 0; i < n; i++) if (g->matrix[u][i] < GRAPH_INFINITY) {
                if(--in_degree[i] == 0)
                    stack_push(&s, i);
        }
    }

    free(in_degree);
    if(count != n) { /* 有环*/
        return 0;
    } else { /* 无环*/
        return 1;
    }
}


/* test

输入数据:

6 8
A C 10
A E 30
A F 100
B C 5
C D 50
D 5 10
E D 20
E F 60

输出:

B A E F C D
*/
int main() {
    int i, j, k, m, n;
    char chx, chy;
    graph_weight_t cost;

    /* 读取节点和边的数目 */
    scanf("%d%d", &m, &n);
    getchar(); // 消耗回车键
    g.vertices_num = m;
    g.edges_num = n;
    g.directed = 1;
    for (i = 0; i < m; i++) g.vertices[i] = 'A' + i;

    /* 初始化图，所有节点间距离为无穷大 */
    for (i = 0; i < m; i++) {
        for (j = 0; j < m; j++) {
            g.matrix[i][j] = GRAPH_INFINITY;
        }
    }

    /* 读取边信息 */
    for (k = 0; k < n; k++) {
        scanf("%c %c %d", &chx, &chy, &cost);
        getchar();
        i = chx - 'A';
        j = chy - 'A';
        g.matrix[i][j] = cost;
    }

    /* 拓扑排序 */
    mgraph_topological_sort(&g, topological);
    for (i = 0; i < m; i++) {
        printf("%c ", g.vertices[topological[i]]);
    }
    return 0;
}
\end{Codex}

\subsubsection{算法分析}
对有$n$个顶点和$e$条边的AOV网络而言，求各顶点的入度所需时间为$O(e)$，建立零入度顶点栈所需时间为$O(n)$；在拓扑排序过程中，若有向图无环，每个顶进一次栈出一次栈，顶点入度减1的操作共执行了$e$次。所以总的时间复杂度为$O(n+e)$。

当有向图中无环时，也可以利用深度优先搜索进行拓扑排序。因为图中无环，深度优先遍历不会死循环。进行深度优先遍历时，最先退出DFS函数的顶点即为出度为零的顶点，是拓扑有序序列的最后一个顶点。由此，按退出DFS函数的先后次序记录下来的顶点序列即为逆向的拓扑有序序列。

	
\section{关键路径} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
用有向边上的权值表示活动的持续时间，用顶点表示时间，这样的有向图叫做边表示的活动网络(Activity On Edge Network)，简称\textbf{AOE网络}。

路径最长的路径叫做\textbf{关键路径}(Critical Path)。假设开始点为$v_1$，从$v_1$到$v_i$的最长路径长度叫做事件$v_i$的最早发生时间。这个事件决定了所有以$v_i$为尾的弧所表示的活动的最早开始时间。我们用$e(i)$表示活动$a_i$的最早开始时间。还可以定义一个活动的最迟开始时间$l(i)$，这是在不推迟整个工程完成的前提下，活动$a_i$最迟必须开始进行的时间。两者之差$l(i)-e(i)$意味着完成活动$a_i$的时间余量。我们把$l(i)=e(i)$的活动叫做关键活动。

设活动$a_i$由弧$<j, k>$表示，为了求得活动的$e(i)$和$l(i)$，首先应求得事件的最早发生时间$ve(j)$和最迟发生时间$vl(j)$，其持续时间记为$dut(<j, k>)$，则有如下关系
\begin{eqnarray}
e(i) &=& ve(j) \nonumber \\
l(i) &=& vl(k)-dut(<j, k>) \nonumber
\end{eqnarray}

求$ve(j)$和$vl(k)$需分两步进行：
\begin{enumerate}
\item 从$ve(0)=0$开始向前递推
$$
ve(j)=\max\left\{ve(i)+dut(<i, j>)\right\}, <i, j> \in T
$$
其中$T$是所有以顶点$j$为弧头的边的集合。
\item 从$vl(n-1)=ve(n-1)$起向后递推
$$
vl(j)=\min\left\{vl(k)-dut(<j, k>)\right\}, <j, k> \in S
$$
其中$S$是所有以顶点$j$为弧尾的边的集合。
\end{enumerate}

例如，对图\ref{fig:criticalpath}(a)所示AOE网络的计算过程如表\ref{tab:criticalpath}所示，可见$a_2$、$a_5$和$a_7$为关键活动，组成一条从起点到终点的关键路径，如图\ref{fig:criticalpath}(b)所示。

\begin{center}
\includegraphics[width=180pt]{criticalpath.png}\\
\figcaption{有向图及其邻接矩阵}\label{fig:criticalpath}
\end{center}

\begin{center}
\tabcaption{图\ref{fig:criticalpath}(a)所示AOE网络的关键路径的计算过程}
\label{tab:criticalpath}
\begin{tabular}{|ccccc|cccc|}
\hline
\textbf{顶点} & & \textbf{ve} & & \textbf{vl} & \textbf{活动} & \textbf{e} & \textbf{l} & \textbf{l-e} \\
\hline
$v_1$ & \multirow{8}{*}{$\downarrow$} & 0 & \multirow{8}{*}{$\uparrow$} & 0 & $a_1$ & 0 & 1 & 1 \\
$v_2$ &                               & 3 &                             & 4 & $a_2$ & 0 & 0 & 0 \\
$v_3$ &                               & 2 &                             & 2 & $a_3$ & 3 & 4 & 1 \\
$v_4$ &                               & 6 &                             & 6 & $a_4$ & 3 & 4 & 1 \\
$v_5$ &                               & 6 &                             & 7 & $a_5$ & 2 & 2 & 0 \\
$v_6$ &                               & 8 &                             & 8 & $a_6$ & 2 & 5 & 3 \\
      &                               &   &                             &   & $a_7$ & 6 & 6 & 0 \\
      &                               &   &                             &   & $a_8$ & 6 & 7 & 1 \\
\hline
\end{tabular}
\end{center}


\section{A*算法} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:astar}

\subsection{八数码问题}
题目见 \S \ref{subsec:eightDigits}。

\subsubsection{代码}
\begin{Codex}[label=eight_digits_astar.c]
/**
 简单解释几个要点,便于理解代码.
 1. 怎么判断是否有解？只要计算出的逆序个数总和为奇数，该数据必然无解
 2. 如何判断某一状态是否到过？本题存在一种完美哈希方案，即用康托展开。
    详见 http://128kj.iteye.com/blog/1699795
    2.1.将一个状态视为数字 0-8 的一个排列，将此排列转化为序数，作为此状
 态的 HASH 值。0表示空格.转化算法此处不再赘述。

    2.2.排列转化为序数，用序数作为hash值
    例，1 2 3 这三个数字的全排列，按字典序，依次为
 123 -- 0
 132 -- 1
 213 -- 2
 231 -- 3
 312 -- 4
 321 -- 5
 其中，左侧为排列，右侧为其序数。
 
 3.使用数据结构 堆 加速挑选最优值。
 
 4.函数 g 的计算，此状态在搜索树中已经走过的路径的节点数.
 
 5.估价函数 h ，采用曼哈顿距离, 见代码 calcH 函数。曼哈顿距离的定义是，
 假设有两个点(x1,y1),(x2,y2)，则曼哈顿距离L1=|x1-x2| + |y1-y2|
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// 3x3的棋盘，状态最多有 9!种
// 8位变进制数（空格）能表示0到(9!-1)内的所有自然数,恰好有9!个，
// 与状态一一对应，因此可以把状态一一映射到一个8位变进制数
#define     MAX         362880

#define DIGITS 9 // 棋盘中数字的个数，也是变进制数需要的位数
#define     MATRIX_EDGE 3       // 棋盘边长

#define     MOD         10      // 按十取模

typedef struct {
    int state; // 状态
    int parent;     // 父状态
    int flag;   // -1 表示已经展开过了closed，0表示死节点，1 表示还未展开, open
    int g, h, f; // 三个评估函数
    char choice;  // 左右上下四个方向移动，见全局常量 DI DJ DC
} state_t;

state_t states[MAX];  // 全局的一条状态变化路径

int  startIndex, goalIndex; // 开始状态，目标状态对应的hash值

// 目标状态
const int goal = 123456780;
// 每个数字在棋盘中的位置，例如0，在(1,1)=4这个位置上
const int goal_pos[DIGITS] = {8,0,1,2,3,4,5,6,7};
const int space_number = 0; // 空格对应着数字 0

// 上下左右四个方向
const int DI[] = {-1, 1, 0, 0};
const int DJ[] = {0, 0, -1, 1};
const char DC[] = { 'u', 'd', 'l', 'r' };

// 9 位变进制数，每个位数的单位，0!~8!
const int fac[] = {40320, 5040, 720, 120, 24, 6, 2, 1, 1};

/**
 * @brief 计算状态的hash值，这里用康托展开，是完美哈希.
 *
 * @param[in] s 当前状态
 * @return 序数，作为hash值
 */
int hash(int s) {
    int i, j;
    int d[DIGITS];
    int key = 0;

    for(i = DIGITS - 1; i >=0; i--) {
        d[i] = s % MOD;
        s /= MOD;
    }
    
    for (i = 0; i < DIGITS; i++) {
        int c = 0; // 逆序数
        for (j = i + 1; j < DIGITS; j++) {
            if(d[j] < d[i]) {
                c++;
            }
        }
        key += c * fac[i];
    }
    
    return key;
}


/**
 * 估价函数h。
 * @param s 状态
 * @return 预估代价
 */
int calcH(int s) {
    int i;
    int h = 0;
    
    for (i = DIGITS - 1; i >= 0; --i) {
        const int p = s % 10;
        s /= 10;
        // 曼哈顿距离
        h += abs(i / MATRIX_EDGE - goal_pos[p] / MATRIX_EDGE) +
            abs(i % MATRIX_EDGE - goal_pos[p] % MATRIX_EDGE);
    }
    return h;
}

/**
 * @brief 输入.
 * @return  成功返回数字，失败返回0
 * @remark 《算法竞赛入门经典》第131页7.5.3节，是用0表示空格，
 * POJ 1077是用'x'表示空格，前者简化了一点，POJ 1077还需要把'x'映射成0
 */
int input() {
    int ch, i;
    int start = 0;
    for (i = 0; i < DIGITS; ++i) {
        do {
            ch = getchar();
        } while ((ch != EOF) && ((ch < '1') || (ch > '8')) && (ch != 'x'));
        if (ch == EOF) return 0;
        if (ch == 'x') start = start * MOD + space_number; // x 映射成数字 0
        else             start = start * MOD + ch - '0';
    }
    return start;
}

/**
 * 计算一个排列的逆序数，0 除外.
 */
int inversion_count(int permutation) {
    int i, j;
    int d[DIGITS];
    int c = 0; // 逆序数

    for(i = DIGITS - 1; i >=0; i--) {
        d[i] = permutation % MOD;
        permutation /= MOD;
    }
    
    for (i = 1; i < DIGITS; i++)  if (d[i] != space_number) {
        for (j = 0; j < i; j++) {
            if(d[j] != space_number) {
                if (d[j] > d[i]) {
                    c++;
                }
            }
        }
    }
    return c;
}

/**
 * 判断是否无解.
 *
 * 求出除0之外所有数字的逆序数之和，也就是每个数字后面比它小的数字的个数的和，
 * 称为这个状态的逆序。若两个状态的逆序奇偶性相同，则可相互到达，否则不可相互到达。
 * 由于原始状态的逆序数为0（偶数），因此逆序数为偶数的目标状态有解。
 *
 * @param s 目标状态
 * @return 1表示无解，0表示有解
 */
int not_solvable(const int s) {
    return inversion_count(s) % 2;
}

// 存放 next()的输出结果
char choice[4]; // 四个防线
int nextIndex[4]; // 接下来的四个状态

/*
 * @brief 向四个方向扩展
 * @param[in] s 状态
 * @return 无
 */
void next(int s) {
    int i, j, k;
    int p[MATRIX_EDGE][MATRIX_EDGE]; // 一个状态对应的矩阵
    int i0, j0;  // 空格位置

    for (i = MATRIX_EDGE - 1; i >= 0; i--) {
        for (j = MATRIX_EDGE - 1; j >= 0; j--) {
            p[i][j] = s % MOD;
            s /= MOD;
            if (p[i][j] == space_number) {
                i0 = i;
                j0 = j;
            }
        }
    }
    // 向四个方向探索
    for (k = 0; k < 4; ++k) {
        const int sx = i0 + DI[k]; // 空格的新位置(sx, sy)
        const int sy = j0 + DJ[k];
        if ((sx >= 0) && (sx < 3) && (sy >= 0) && (sy < 3)) {
            int key;
            p[i0][j0] = p[sx][sy];
            p[sx][sy] = space_number;
            // 移动空格后，计算新的状态
            s = 0;
            for (i = 0; i < MATRIX_EDGE; i++)
                for (j = 0; j < MATRIX_EDGE; j++)
                    s = s * MOD + p[i][j];
            p[sx][sy] = p[i0][j0]; // 将矩阵还原，(i0, j0)可以不管
            
            key = nextIndex[k] = hash(s);
            choice[k] = DC[k];
            if (states[key].state == 0) { // 该状态还没有出现过
                states[key].state = s;
                states[key].h = calcH(s);
            }
        } else {// 越界了
            nextIndex[k] = -1;
        }
    }
}


#include "heap.c" // 等价于复制粘贴
heap_t heap;
int heapIndex[MAX + 4]; // 状态 x 在heap中的下标

/**
 * @brief A*搜索
 * @param[in] start 初始状态
 * @return 如果无解，返回0，如果有解返回1
 */
int astar(const int start) {
    int i, j, k, ng, nf;
    if (not_solvable(start)) return 0;

    startIndex = hash(start);
    goalIndex  = hash(goal);
    if (start == goal) return 1;
    
    memset(states, 0, sizeof(states));
    states[startIndex].state = start;
    states[startIndex].flag    = 1;
    states[startIndex].g       = 0;
    states[startIndex].h       = states[startIndex].f = calcH(start);

    heap_push(&heap, startIndex);
    while(!heap_empty(&heap)) {
        i = heap_top(&heap); heap_pop(&heap);
        if (i == goalIndex) return 1; // 找到目标，返回

        states[i].flag = -1;
        ng = states[i].g + 1;
        next(states[i].state);
        for (k = 0; k < 4; ++k) {
            j = nextIndex[k];
            if (j < 0) continue;
            nf = ng + states[j].h;
            if ((states[j].flag == 0) || ((states[j].flag == 1) &&
                (nf < states[j].f))) {
                states[j].parent = i;
                states[j].choice = choice[k];
                states[j].g    = ng;
                states[j].f    = nf;
                if (states[j].flag > 0) {
                    heap_sift_up(&heap, heapIndex[j]);
                    heap_sift_down(&heap, heapIndex[j]);
                } else {
                    heap_push(&heap, j);
                    states[j].flag = 1;
                }
            }
        }
    }
    return 0;
}

#include "stack.c" // 等价于复制粘贴
/**
 * @brief 打印移动序列.
 * @return 无
 */
void output() {
    int i;
    stack_t stack;
    stack_init(&stack, MAX);

    for (i = goalIndex; i != startIndex; i = states[i].parent) {
        stack_push(&stack, states[i].choice);
    }
    while(!stack_empty(&stack)) {
        printf("%c", stack_top(&stack));
        stack_pop(&stack);
    }
    
    printf("\n");
    stack_uninit(&stack);
}

/**
 * @brief 打印棋盘的每次变化.
 * @return 无
 */
void output1() {
    int i;
    int d[DIGITS];
    stack_t stack;
    stack_init(&stack, MAX);
    
    for (i = goalIndex; i != startIndex; i = states[i].parent) {
        stack_push(&stack, states[i].state);
    }
    stack_push(&stack, states[startIndex].state);
    
    while(!stack_empty(&stack)) {
        stack_elem_t tmp = stack_top(&stack); 
        stack_pop(&stack);
        for(i = DIGITS - 1; i >=0; i--) {
            d[i] = tmp % MOD;
            tmp /= MOD;
        }
        for(i = 0; i < DIGITS; i++) {
            if((i + 1) % MATRIX_EDGE == 0) {
                printf("%d\n", d[i]);
            } else {
                printf("%d ", d[i]);
            }
        }
        printf("\n");
    }
    stack_uninit(&stack);
}

int main() {
    const int start = input();
    heap_init(&heap, MAX + 4, cmp_int);
    if (start > 0) {
        if (astar(start)) {
            output();
        } else {
            printf("no solution\n");
        }
    }
    heap_uninit(&heap);
    return 0;
}
\end{Codex}
